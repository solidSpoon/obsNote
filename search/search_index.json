{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Obsidian Notes \u00b6 My public notes","title":"Obsidian Notes"},{"location":"#obsidian-notes","text":"My public notes","title":"Obsidian Notes"},{"location":"Elastic_Stack/","text":"This repository contains all of the queries used within the Complete Guide to Elasticsearch course .","title":"Index"},{"location":"Elastic_Stack/1_Getting_Started/1.1_Inspecting_The_Cluster/","text":"Inspecting the cluster \u00b6 Checking the cluster's health \u00b6 GET /_cluster/health Listing the cluster's nodes \u00b6 GET /_cat/nodes?v Listing the cluster's indices \u00b6 GET /_cat/indices?v&expand_wildcards=all","title":"Inspecting the cluster"},{"location":"Elastic_Stack/1_Getting_Started/1.1_Inspecting_The_Cluster/#inspecting-the-cluster","text":"","title":"Inspecting the cluster"},{"location":"Elastic_Stack/1_Getting_Started/1.1_Inspecting_The_Cluster/#checking-the-clusters-health","text":"GET /_cluster/health","title":"Checking the cluster's health"},{"location":"Elastic_Stack/1_Getting_Started/1.1_Inspecting_The_Cluster/#listing-the-clusters-nodes","text":"GET /_cat/nodes?v","title":"Listing the cluster's nodes"},{"location":"Elastic_Stack/1_Getting_Started/1.1_Inspecting_The_Cluster/#listing-the-clusters-indices","text":"GET /_cat/indices?v&expand_wildcards=all","title":"Listing the cluster's indices"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/","text":"Adding more nodes to the cluster (for development) \u00b6 Checking the cluster's health \u00b6 GET /_cluster/health Checking the shard distribution \u00b6 GET /_cat/shards?v Generating an enrollment token \u00b6 When adding a new node to an existing Elasticsearch cluster, we first need to generate an enrollment token. # macOS & Linux bin/elasticsearch-create-enrollment-token --scope node # Windows bin\\elasticsearch-create-enrollment-token.bat -s node Adding a new node to the cluster \u00b6 To add a new node to an existing cluster, run the following command. Remember to have the working directory set to the new node's $ES_HOME directory (use the cd command for this). # macOS & Linux bin/elasticsearch --enrollment-token [INSERT_ENROLLMENT_TOKEN_HERE] # Windows bin\\elasticsearch.bat --enrollment-token [INSERT_ENROLLMENT_TOKEN_HERE] Once the node has been added, starting up the node again in the future is as simple as running bin/elasticsearch (macOS & Linux) or bin\\elasticsearch.bat (Windows).","title":"Adding more nodes to the cluster (for development)"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/#adding-more-nodes-to-the-cluster-for-development","text":"","title":"Adding more nodes to the cluster (for development)"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/#checking-the-clusters-health","text":"GET /_cluster/health","title":"Checking the cluster's health"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/#checking-the-shard-distribution","text":"GET /_cat/shards?v","title":"Checking the shard distribution"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/#generating-an-enrollment-token","text":"When adding a new node to an existing Elasticsearch cluster, we first need to generate an enrollment token. # macOS & Linux bin/elasticsearch-create-enrollment-token --scope node # Windows bin\\elasticsearch-create-enrollment-token.bat -s node","title":"Generating an enrollment token"},{"location":"Elastic_Stack/1_Getting_Started/adding-more-nodes-to-the-cluster/#adding-a-new-node-to-the-cluster","text":"To add a new node to an existing cluster, run the following command. Remember to have the working directory set to the new node's $ES_HOME directory (use the cd command for this). # macOS & Linux bin/elasticsearch --enrollment-token [INSERT_ENROLLMENT_TOKEN_HERE] # Windows bin\\elasticsearch.bat --enrollment-token [INSERT_ENROLLMENT_TOKEN_HERE] Once the node has been added, starting up the node again in the future is as simple as running bin/elasticsearch (macOS & Linux) or bin\\elasticsearch.bat (Windows).","title":"Adding a new node to the cluster"},{"location":"Elastic_Stack/1_Getting_Started/overview-of-node-roles/","text":"Overview of node roles \u00b6 Listing the cluster's nodes (and their roles) \u00b6 GET /_cat/nodes?v","title":"Overview of node roles"},{"location":"Elastic_Stack/1_Getting_Started/overview-of-node-roles/#overview-of-node-roles","text":"","title":"Overview of node roles"},{"location":"Elastic_Stack/1_Getting_Started/overview-of-node-roles/#listing-the-clusters-nodes-and-their-roles","text":"GET /_cat/nodes?v","title":"Listing the cluster's nodes (and their roles)"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/","text":"Sending queries with cURL \u00b6 Handling self signed certificates \u00b6 Elasticsearch is protected with a self signed certificate by default, which HTTP clients do not trust. Sending a request will therefore fail with a certificate error. To fix this, we have a couple of options. 1. Skip certificate verification \u00b6 One option is to entirely skip the verification of the certificate. This is not exactly best practice, but if you are just developing with a local cluster, then it might be just fine. To ignore the certificate, use either the --insecure flag or -k . curl --insecure [...] curl -k [...] 2. Provide the CA certificate \u00b6 A better approach is to provide the CA certificate so that the TLS certificate is not just ignored. The path to the file can be supplied with the --cacert argument. The CA certificate is typically stored within the config/certs directory, although the certs directory may be at the root of your Elasticsearch home directory ( $ES_HOME ) depending on how you installed Elasticsearch. # macOS & Linux cd /path/to/elasticsearch curl --cacert config/certs/http_ca.crt [...] # Windows cd C:\\Path\\To\\Elasticsearch curl --cacert config\\certs\\http_ca.crt [...] Alternatively, you can specify the absolute path to the file. Authentication \u00b6 All requests made to Elasticsearch must be authenticated. For local deployments, use the password that was generated for the elastic user the first time Elasticsearch started up. curl -u elastic [...] The above will prompt you to enter the password when running the command. Alternatively, you can enter the password directly within the command as follows (without the brackets). curl -u elastic:[YOUR_PASSWORD_HERE] [...] Note that this exposes your password within the terminal, so this is not best practice from a security perspective. Adding a request body & Content-Type header \u00b6 To send data within the request, use the -d argument, e.g. for the match_all query. Note that using single quotes does not work on Windows, so each double quote within the JSON object must be escaped. # macOS & Linux curl [...] https://localhost:9200/products/_search -d '{ \"query\": { \"match_all\": {} } }' # Windows curl [...] https://localhost:9200/products/_search -d \"{ \\\"query\\\": { \\\"match_all\\\": {} } }\" When sending data (typically JSON), we need to tell Elasticsearch which type of data we are sending. This can be done with the Content-Type HTTP header. Simply add it with cURL's -H argument. curl -H \"Content-Type:application/json\" [...] Specifying the HTTP verb \u00b6 You may also specify the HTTP verb (e.g. POST ). This is necessary for some endpoints, such as when indexing documents. GET is assumed by default. curl -X POST [...] All together now \u00b6 # macOS & Linux curl --cacert config/certs/http_ca.crt -u elastic https://localhost:9200/products/_search -d '{ \"query\": { \"match_all\": {} } }' # Windows curl --cacert config\\certs\\http_ca.crt -u elastic https://localhost:9200/products/_search -d \"{ \\\"query\\\": { \\\"match_all\\\": {} } }\"","title":"Sending queries with cURL"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#sending-queries-with-curl","text":"","title":"Sending queries with cURL"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#handling-self-signed-certificates","text":"Elasticsearch is protected with a self signed certificate by default, which HTTP clients do not trust. Sending a request will therefore fail with a certificate error. To fix this, we have a couple of options.","title":"Handling self signed certificates"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#1-skip-certificate-verification","text":"One option is to entirely skip the verification of the certificate. This is not exactly best practice, but if you are just developing with a local cluster, then it might be just fine. To ignore the certificate, use either the --insecure flag or -k . curl --insecure [...] curl -k [...]","title":"1. Skip certificate verification"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#2-provide-the-ca-certificate","text":"A better approach is to provide the CA certificate so that the TLS certificate is not just ignored. The path to the file can be supplied with the --cacert argument. The CA certificate is typically stored within the config/certs directory, although the certs directory may be at the root of your Elasticsearch home directory ( $ES_HOME ) depending on how you installed Elasticsearch. # macOS & Linux cd /path/to/elasticsearch curl --cacert config/certs/http_ca.crt [...] # Windows cd C:\\Path\\To\\Elasticsearch curl --cacert config\\certs\\http_ca.crt [...] Alternatively, you can specify the absolute path to the file.","title":"2. Provide the CA certificate"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#authentication","text":"All requests made to Elasticsearch must be authenticated. For local deployments, use the password that was generated for the elastic user the first time Elasticsearch started up. curl -u elastic [...] The above will prompt you to enter the password when running the command. Alternatively, you can enter the password directly within the command as follows (without the brackets). curl -u elastic:[YOUR_PASSWORD_HERE] [...] Note that this exposes your password within the terminal, so this is not best practice from a security perspective.","title":"Authentication"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#adding-a-request-body-content-type-header","text":"To send data within the request, use the -d argument, e.g. for the match_all query. Note that using single quotes does not work on Windows, so each double quote within the JSON object must be escaped. # macOS & Linux curl [...] https://localhost:9200/products/_search -d '{ \"query\": { \"match_all\": {} } }' # Windows curl [...] https://localhost:9200/products/_search -d \"{ \\\"query\\\": { \\\"match_all\\\": {} } }\" When sending data (typically JSON), we need to tell Elasticsearch which type of data we are sending. This can be done with the Content-Type HTTP header. Simply add it with cURL's -H argument. curl -H \"Content-Type:application/json\" [...]","title":"Adding a request body &amp; Content-Type header"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#specifying-the-http-verb","text":"You may also specify the HTTP verb (e.g. POST ). This is necessary for some endpoints, such as when indexing documents. GET is assumed by default. curl -X POST [...]","title":"Specifying the HTTP verb"},{"location":"Elastic_Stack/1_Getting_Started/sending-queries-with-curl/#all-together-now","text":"# macOS & Linux curl --cacert config/certs/http_ca.crt -u elastic https://localhost:9200/products/_search -d '{ \"query\": { \"match_all\": {} } }' # Windows curl --cacert config\\certs\\http_ca.crt -u elastic https://localhost:9200/products/_search -d \"{ \\\"query\\\": { \\\"match_all\\\": {} } }\"","title":"All together now"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/","text":"Setting up Elasticsearch & Kibana on macOS & Linux \u00b6 Extracting the archives \u00b6 Both the Elasticsearch and Kibana archives can be extracted by using the below commands. Alternatively, simply double-clicking them should do the trick. cd /path/to/archive/directory tar -zxf archive.tar.gz Starting up Elasticsearch \u00b6 cd /path/to/elasticsearch bin/elasticsearch Resetting the elastic user's password \u00b6 If you lose the password for the elastic user, it can be reset with the following commands. cd /path/to/elasticsearch bin/elasticsearch-reset-password -u elastic Generating a new Kibana enrollment token \u00b6 If you need to generate a new enrollment token for Kibana, this can be done with the following commands. cd /path/to/elasticsearch bin/elasticsearch-create-enrollment-token --scope kibana Disabling Gatekeeper for Kibana directory \u00b6 macOS contains a security feature named Gatekeeper, which prevents Kibana from starting up. We can disable it for just the Kibana directory, which allows Kibana to start up correctly. Simply use the following command to do so. xattr -d -r com.apple.quarantine /path/to/kibana Starting up Kibana \u00b6 cd /path/to/kibana bin/kibana","title":"Setting up Elasticsearch & Kibana on macOS & Linux"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#setting-up-elasticsearch-kibana-on-macos-linux","text":"","title":"Setting up Elasticsearch &amp; Kibana on macOS &amp; Linux"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#extracting-the-archives","text":"Both the Elasticsearch and Kibana archives can be extracted by using the below commands. Alternatively, simply double-clicking them should do the trick. cd /path/to/archive/directory tar -zxf archive.tar.gz","title":"Extracting the archives"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#starting-up-elasticsearch","text":"cd /path/to/elasticsearch bin/elasticsearch","title":"Starting up Elasticsearch"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#resetting-the-elastic-users-password","text":"If you lose the password for the elastic user, it can be reset with the following commands. cd /path/to/elasticsearch bin/elasticsearch-reset-password -u elastic","title":"Resetting the elastic user's password"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#generating-a-new-kibana-enrollment-token","text":"If you need to generate a new enrollment token for Kibana, this can be done with the following commands. cd /path/to/elasticsearch bin/elasticsearch-create-enrollment-token --scope kibana","title":"Generating a new Kibana enrollment token"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#disabling-gatekeeper-for-kibana-directory","text":"macOS contains a security feature named Gatekeeper, which prevents Kibana from starting up. We can disable it for just the Kibana directory, which allows Kibana to start up correctly. Simply use the following command to do so. xattr -d -r com.apple.quarantine /path/to/kibana","title":"Disabling Gatekeeper for Kibana directory"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-macos-linux/#starting-up-kibana","text":"cd /path/to/kibana bin/kibana","title":"Starting up Kibana"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/","text":"Setting up Elasticsearch & Kibana on Windows \u00b6 Starting up Elasticsearch \u00b6 cd path\\to\\elasticsearch bin\\elasticsearch.bat Resetting the elastic user's password \u00b6 If you lose the password for the elastic user, it can be reset with the following commands. cd path\\to\\elasticsearch bin\\elasticsearch-reset-password.bat -u elastic Generating a new Kibana enrollment token \u00b6 If you need to generate a new enrollment token for Kibana, this can be done with the following commands. cd path\\to\\elasticsearch bin\\elasticsearch-create-enrollment-token.bat -s kibana Starting up Kibana \u00b6 cd path\\to\\kibana bin\\kibana.bat","title":"Setting up Elasticsearch & Kibana on Windows"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/#setting-up-elasticsearch-kibana-on-windows","text":"","title":"Setting up Elasticsearch &amp; Kibana on Windows"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/#starting-up-elasticsearch","text":"cd path\\to\\elasticsearch bin\\elasticsearch.bat","title":"Starting up Elasticsearch"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/#resetting-the-elastic-users-password","text":"If you lose the password for the elastic user, it can be reset with the following commands. cd path\\to\\elasticsearch bin\\elasticsearch-reset-password.bat -u elastic","title":"Resetting the elastic user's password"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/#generating-a-new-kibana-enrollment-token","text":"If you need to generate a new enrollment token for Kibana, this can be done with the following commands. cd path\\to\\elasticsearch bin\\elasticsearch-create-enrollment-token.bat -s kibana","title":"Generating a new Kibana enrollment token"},{"location":"Elastic_Stack/1_Getting_Started/setting-up-elasticsearch-kibana-windows/#starting-up-kibana","text":"cd path\\to\\kibana bin\\kibana.bat","title":"Starting up Kibana"},{"location":"Elastic_Stack/1_Getting_Started/sharding-and-scalability/","text":"Sharding and scalability \u00b6 Listing the cluster's indices \u00b6 GET /_cat/indices?v","title":"Sharding and scalability"},{"location":"Elastic_Stack/1_Getting_Started/sharding-and-scalability/#sharding-and-scalability","text":"","title":"Sharding and scalability"},{"location":"Elastic_Stack/1_Getting_Started/sharding-and-scalability/#listing-the-clusters-indices","text":"GET /_cat/indices?v","title":"Listing the cluster's indices"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/","text":"Understanding replication \u00b6 Creating a new index \u00b6 PUT /pages Checking the cluster's health \u00b6 GET /_cluster/health Listing the cluster's indices \u00b6 GET /_cat/indices?v Listing the cluster's shards \u00b6 GET /_cat/shards?v","title":"Understanding replication"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/#understanding-replication","text":"","title":"Understanding replication"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/#creating-a-new-index","text":"PUT /pages","title":"Creating a new index"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/#checking-the-clusters-health","text":"GET /_cluster/health","title":"Checking the cluster's health"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/#listing-the-clusters-indices","text":"GET /_cat/indices?v","title":"Listing the cluster's indices"},{"location":"Elastic_Stack/1_Getting_Started/understanding-replication/#listing-the-clusters-shards","text":"GET /_cat/shards?v","title":"Listing the cluster's shards"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/","text":"Batch processing \u00b6 Indexing documents \u00b6 POST /_bulk { \"index\": { \"_index\": \"products\", \"_id\": 200 } } { \"name\": \"Espresso Machine\", \"price\": 199, \"in_stock\": 5 } { \"create\": { \"_index\": \"products\", \"_id\": 201 } } { \"name\": \"Milk Frother\", \"price\": 149, \"in_stock\": 14 } Updating and deleting documents \u00b6 POST /_bulk { \"update\": { \"_index\": \"products\", \"_id\": 201 } } { \"doc\": { \"price\": 129 } } { \"delete\": { \"_index\": \"products\", \"_id\": 200 } } Specifying the index name in the request path \u00b6 POST /products/_bulk { \"update\": { \"_id\": 201 } } { \"doc\": { \"price\": 129 } } { \"delete\": { \"_id\": 200 } } Retrieving all documents \u00b6 GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Batch processing"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/#batch-processing","text":"","title":"Batch processing"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/#indexing-documents","text":"POST /_bulk { \"index\": { \"_index\": \"products\", \"_id\": 200 } } { \"name\": \"Espresso Machine\", \"price\": 199, \"in_stock\": 5 } { \"create\": { \"_index\": \"products\", \"_id\": 201 } } { \"name\": \"Milk Frother\", \"price\": 149, \"in_stock\": 14 }","title":"Indexing documents"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/#updating-and-deleting-documents","text":"POST /_bulk { \"update\": { \"_index\": \"products\", \"_id\": 201 } } { \"doc\": { \"price\": 129 } } { \"delete\": { \"_index\": \"products\", \"_id\": 200 } }","title":"Updating and deleting documents"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/#specifying-the-index-name-in-the-request-path","text":"POST /products/_bulk { \"update\": { \"_id\": 201 } } { \"doc\": { \"price\": 129 } } { \"delete\": { \"_id\": 200 } }","title":"Specifying the index name in the request path"},{"location":"Elastic_Stack/3_Managing_Documents/batch-processing/#retrieving-all-documents","text":"GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Retrieving all documents"},{"location":"Elastic_Stack/3_Managing_Documents/creating-and-deleting-indices/","text":"Creating & Deleting Indices \u00b6 Deleting an index \u00b6 DELETE /pages Creating an index (with settings) \u00b6 PUT /products { \"settings\": { \"number_of_shards\": 2, \"number_of_replicas\": 2 } }","title":"Creating & Deleting Indices"},{"location":"Elastic_Stack/3_Managing_Documents/creating-and-deleting-indices/#creating-deleting-indices","text":"","title":"Creating &amp; Deleting Indices"},{"location":"Elastic_Stack/3_Managing_Documents/creating-and-deleting-indices/#deleting-an-index","text":"DELETE /pages","title":"Deleting an index"},{"location":"Elastic_Stack/3_Managing_Documents/creating-and-deleting-indices/#creating-an-index-with-settings","text":"PUT /products { \"settings\": { \"number_of_shards\": 2, \"number_of_replicas\": 2 } }","title":"Creating an index (with settings)"},{"location":"Elastic_Stack/3_Managing_Documents/delete-by-query/","text":"Delete by query \u00b6 Deleting documents that match a given query \u00b6 POST /products/_delete_by_query { \"query\": { \"match_all\": { } } } Ignoring (counting) version conflicts \u00b6 The conflicts key may be added as a query parameter instead, i.e. ?conflicts=proceed . POST /products/_delete_by_query { \"conflicts\": \"proceed\", \"query\": { \"match_all\": { } } }","title":"Delete by query"},{"location":"Elastic_Stack/3_Managing_Documents/delete-by-query/#delete-by-query","text":"","title":"Delete by query"},{"location":"Elastic_Stack/3_Managing_Documents/delete-by-query/#deleting-documents-that-match-a-given-query","text":"POST /products/_delete_by_query { \"query\": { \"match_all\": { } } }","title":"Deleting documents that match a given query"},{"location":"Elastic_Stack/3_Managing_Documents/delete-by-query/#ignoring-counting-version-conflicts","text":"The conflicts key may be added as a query parameter instead, i.e. ?conflicts=proceed . POST /products/_delete_by_query { \"conflicts\": \"proceed\", \"query\": { \"match_all\": { } } }","title":"Ignoring (counting) version conflicts"},{"location":"Elastic_Stack/3_Managing_Documents/deleting-documents/","text":"Deleting documents \u00b6 DELETE /products/_doc/101","title":"Deleting documents"},{"location":"Elastic_Stack/3_Managing_Documents/deleting-documents/#deleting-documents","text":"DELETE /products/_doc/101","title":"Deleting documents"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/","text":"Importing data with cURL \u00b6 Navigating to bulk file directory \u00b6 cd /path/to/data/file/directory Examples \u00b6 # macOS and Linux cd ~/Desktop # Windows cd C:\\Users\\[your_username]\\Desktop Importing data into local cluster \u00b6 curl -H \"Content-Type:application/x-ndjson\" -XPOST http://localhost:9200/products/_bulk --data-binary \"@products-bulk.json\" Importing data into Elastic Cloud \u00b6 curl -H \"Content-Type:application/x-ndjson\" -XPOST -u username:password https://elastic-cloud-endpoint.com:9243/products/_bulk --data-binary \"@products-bulk.json\"","title":"Importing data with cURL"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/#importing-data-with-curl","text":"","title":"Importing data with cURL"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/#navigating-to-bulk-file-directory","text":"cd /path/to/data/file/directory","title":"Navigating to bulk file directory"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/#examples","text":"# macOS and Linux cd ~/Desktop # Windows cd C:\\Users\\[your_username]\\Desktop","title":"Examples"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/#importing-data-into-local-cluster","text":"curl -H \"Content-Type:application/x-ndjson\" -XPOST http://localhost:9200/products/_bulk --data-binary \"@products-bulk.json\"","title":"Importing data into local cluster"},{"location":"Elastic_Stack/3_Managing_Documents/importing-data-with-curl/#importing-data-into-elastic-cloud","text":"curl -H \"Content-Type:application/x-ndjson\" -XPOST -u username:password https://elastic-cloud-endpoint.com:9243/products/_bulk --data-binary \"@products-bulk.json\"","title":"Importing data into Elastic Cloud"},{"location":"Elastic_Stack/3_Managing_Documents/indexing-documents/","text":"Indexing documents \u00b6 Indexing document with auto generated ID: \u00b6 POST /products/_doc { \"name\": \"Coffee Maker\", \"price\": 64, \"in_stock\": 10 } Indexing document with custom ID: \u00b6 PUT /products/_doc/100 { \"name\": \"Toaster\", \"price\": 49, \"in_stock\": 4 }","title":"Indexing documents"},{"location":"Elastic_Stack/3_Managing_Documents/indexing-documents/#indexing-documents","text":"","title":"Indexing documents"},{"location":"Elastic_Stack/3_Managing_Documents/indexing-documents/#indexing-document-with-auto-generated-id","text":"POST /products/_doc { \"name\": \"Coffee Maker\", \"price\": 64, \"in_stock\": 10 }","title":"Indexing document with auto generated ID:"},{"location":"Elastic_Stack/3_Managing_Documents/indexing-documents/#indexing-document-with-custom-id","text":"PUT /products/_doc/100 { \"name\": \"Toaster\", \"price\": 49, \"in_stock\": 4 }","title":"Indexing document with custom ID:"},{"location":"Elastic_Stack/3_Managing_Documents/optimistic-concurrency-control/","text":"Optimistic concurrency control \u00b6 Retrieve the document (and its primary term and sequence number) \u00b6 GET /products/_doc/100 Update the in_stock field only if the document has not been updated since retrieving it \u00b6 POST /products/_update/100?if_primary_term=X&if_seq_no=X { \"doc\": { \"in_stock\": 123 } }","title":"Optimistic concurrency control"},{"location":"Elastic_Stack/3_Managing_Documents/optimistic-concurrency-control/#optimistic-concurrency-control","text":"","title":"Optimistic concurrency control"},{"location":"Elastic_Stack/3_Managing_Documents/optimistic-concurrency-control/#retrieve-the-document-and-its-primary-term-and-sequence-number","text":"GET /products/_doc/100","title":"Retrieve the document (and its primary term and sequence number)"},{"location":"Elastic_Stack/3_Managing_Documents/optimistic-concurrency-control/#update-the-in_stock-field-only-if-the-document-has-not-been-updated-since-retrieving-it","text":"POST /products/_update/100?if_primary_term=X&if_seq_no=X { \"doc\": { \"in_stock\": 123 } }","title":"Update the in_stock field only if the document has not been updated since retrieving it"},{"location":"Elastic_Stack/3_Managing_Documents/replacing-documents/","text":"Replacing documents \u00b6 PUT /products/_doc/100 { \"name\": \"Toaster\", \"price\": 79, \"in_stock\": 4 }","title":"Replacing documents"},{"location":"Elastic_Stack/3_Managing_Documents/replacing-documents/#replacing-documents","text":"PUT /products/_doc/100 { \"name\": \"Toaster\", \"price\": 79, \"in_stock\": 4 }","title":"Replacing documents"},{"location":"Elastic_Stack/3_Managing_Documents/retrieving-documents-by-id/","text":"Retrieving documents by ID \u00b6 GET /products/_doc/100","title":"Retrieving documents by ID"},{"location":"Elastic_Stack/3_Managing_Documents/retrieving-documents-by-id/#retrieving-documents-by-id","text":"GET /products/_doc/100","title":"Retrieving documents by ID"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/","text":"Scripted updates \u00b6 ctx is short for context Reducing the current value of in_stock by one \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock--\" } } Assigning an arbitrary value to in_stock \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock = 10\" } } Using parameters within scripts \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock -= params.quantity\", \"params\": { \"quantity\": 4 } } } Conditionally setting the operation to noop \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock == 0) { ctx.op = 'noop'; } ctx._source.in_stock--; \"\"\" } } Conditionally update a field value \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock > 0) { ctx._source.in_stock--; } \"\"\" } } Conditionally delete a document \u00b6 POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock < 0) { ctx.op = 'delete'; } ctx._source.in_stock--; \"\"\" } }","title":"Scripted updates"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#scripted-updates","text":"ctx is short for context","title":"Scripted updates"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#reducing-the-current-value-of-in_stock-by-one","text":"POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock--\" } }","title":"Reducing the current value of in_stock by one"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#assigning-an-arbitrary-value-to-in_stock","text":"POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock = 10\" } }","title":"Assigning an arbitrary value to in_stock"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#using-parameters-within-scripts","text":"POST /products/_update/100 { \"script\": { \"source\": \"ctx._source.in_stock -= params.quantity\", \"params\": { \"quantity\": 4 } } }","title":"Using parameters within scripts"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#conditionally-setting-the-operation-to-noop","text":"POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock == 0) { ctx.op = 'noop'; } ctx._source.in_stock--; \"\"\" } }","title":"Conditionally setting the operation to noop"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#conditionally-update-a-field-value","text":"POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock > 0) { ctx._source.in_stock--; } \"\"\" } }","title":"Conditionally update a field value"},{"location":"Elastic_Stack/3_Managing_Documents/scripted-updates/#conditionally-delete-a-document","text":"POST /products/_update/100 { \"script\": { \"source\": \"\"\" if (ctx._source.in_stock < 0) { ctx.op = 'delete'; } ctx._source.in_stock--; \"\"\" } }","title":"Conditionally delete a document"},{"location":"Elastic_Stack/3_Managing_Documents/update-by-query/","text":"Update by query \u00b6 Updating documents matching a query \u00b6 Replace the match_all query with any query that you would like. POST /products/_update_by_query { \"script\": { \"source\": \"ctx._source.in_stock--\" }, \"query\": { \"match_all\": {} } } Ignoring (counting) version conflicts \u00b6 The conflicts key may be added as a query parameter instead, i.e. ?conflicts=proceed . POST /products/_update_by_query { \"conflicts\": \"proceed\", \"script\": { \"source\": \"ctx._source.in_stock--\" }, \"query\": { \"match_all\": {} } } Matches all of the documents within the products index \u00b6 GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Update by query"},{"location":"Elastic_Stack/3_Managing_Documents/update-by-query/#update-by-query","text":"","title":"Update by query"},{"location":"Elastic_Stack/3_Managing_Documents/update-by-query/#updating-documents-matching-a-query","text":"Replace the match_all query with any query that you would like. POST /products/_update_by_query { \"script\": { \"source\": \"ctx._source.in_stock--\" }, \"query\": { \"match_all\": {} } }","title":"Updating documents matching a query"},{"location":"Elastic_Stack/3_Managing_Documents/update-by-query/#ignoring-counting-version-conflicts","text":"The conflicts key may be added as a query parameter instead, i.e. ?conflicts=proceed . POST /products/_update_by_query { \"conflicts\": \"proceed\", \"script\": { \"source\": \"ctx._source.in_stock--\" }, \"query\": { \"match_all\": {} } }","title":"Ignoring (counting) version conflicts"},{"location":"Elastic_Stack/3_Managing_Documents/update-by-query/#matches-all-of-the-documents-within-the-products-index","text":"GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Matches all of the documents within the products index"},{"location":"Elastic_Stack/3_Managing_Documents/updating-documents/","text":"Updating documents \u00b6 Updating an existing field \u00b6 POST /products/_update/100 { \"doc\": { \"in_stock\": 3 } } Adding a new field \u00b6 Yes, the syntax is the same as the above. ;-) POST /products/_update/100 { \"doc\": { \"tags\": [\"electronics\"] } }","title":"Updating documents"},{"location":"Elastic_Stack/3_Managing_Documents/updating-documents/#updating-documents","text":"","title":"Updating documents"},{"location":"Elastic_Stack/3_Managing_Documents/updating-documents/#updating-an-existing-field","text":"POST /products/_update/100 { \"doc\": { \"in_stock\": 3 } }","title":"Updating an existing field"},{"location":"Elastic_Stack/3_Managing_Documents/updating-documents/#adding-a-new-field","text":"Yes, the syntax is the same as the above. ;-) POST /products/_update/100 { \"doc\": { \"tags\": [\"electronics\"] } }","title":"Adding a new field"},{"location":"Elastic_Stack/3_Managing_Documents/upserts/","text":"Upserts \u00b6 means update or insert POST /products/_update/101 { \"script\": { \"source\": \"ctx._source.in_stock++\" }, \"upsert\": { \"name\": \"Blender\", \"price\": 399, \"in_stock\": 5 } }","title":"Upserts"},{"location":"Elastic_Stack/3_Managing_Documents/upserts/#upserts","text":"means update or insert POST /products/_update/101 { \"script\": { \"source\": \"ctx._source.in_stock++\" }, \"upsert\": { \"name\": \"Blender\", \"price\": 399, \"in_stock\": 5 } }","title":"Upserts"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/debugging-bool-queries-with-named-queries/","text":"Debugging bool queries with named queries \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": { \"query\": \"parmesan\", \"_name\": \"parmesan_must\" } } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": { \"query\": \"tuna\", \"_name\": \"tuna_must_not\" } } } ], \"should\": [ { \"match\": { \"ingredients.name\": { \"query\": \"parsley\", \"_name\": \"parsley_should\" } } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15, \"_name\": \"prep_time_filter\" } } } ] } } }","title":"Debugging `bool` queries with named queries"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/debugging-bool-queries-with-named-queries/#debugging-bool-queries-with-named-queries","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": { \"query\": \"parmesan\", \"_name\": \"parmesan_must\" } } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": { \"query\": \"tuna\", \"_name\": \"tuna_must_not\" } } } ], \"should\": [ { \"match\": { \"ingredients.name\": { \"query\": \"parsley\", \"_name\": \"parsley_should\" } } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15, \"_name\": \"prep_time_filter\" } } } ] } } }","title":"Debugging bool queries with named queries"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/how-the-match-query-works/","text":"How the match query works \u00b6 The two queries below are equivalent \u00b6 GET /recipe/_search { \"query\": { \"match\": { \"title\": \"pasta carbonara\" } } } GET /recipe/_search { \"query\": { \"bool\": { \"should\": [ { \"term\": { \"title\": \"pasta\" } }, { \"term\": { \"title\": \"carbonara\" } } ] } } } The two queries below are equivalent \u00b6 GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta carbonara\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"term\": { \"title\": \"pasta\" } }, { \"term\": { \"title\": \"carbonara\" } } ] } } }","title":"How the `match` query works"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/how-the-match-query-works/#how-the-match-query-works","text":"","title":"How the match query works"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/how-the-match-query-works/#the-two-queries-below-are-equivalent","text":"GET /recipe/_search { \"query\": { \"match\": { \"title\": \"pasta carbonara\" } } } GET /recipe/_search { \"query\": { \"bool\": { \"should\": [ { \"term\": { \"title\": \"pasta\" } }, { \"term\": { \"title\": \"carbonara\" } } ] } } }","title":"The two queries below are equivalent"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/how-the-match-query-works/#the-two-queries-below-are-equivalent_1","text":"GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta carbonara\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"term\": { \"title\": \"pasta\" } }, { \"term\": { \"title\": \"carbonara\" } } ] } } }","title":"The two queries below are equivalent"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/","text":"Querying with boolean logic \u00b6 Adding query clauses to the must key \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } }, { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } } Moving the range query to the filter key \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } } Adding a query clause to the must_not key \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": \"tuna\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } } Adding a query clause to the should key \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": \"tuna\" } } ], \"should\": [ { \"match\": { \"ingredients.name\": \"parsley\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } } The behavior of should query clauses depends \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"pasta\" } } ], \"should\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ] } } } GET /recipe/_search { \"query\": { \"bool\": { \"should\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ] } } }","title":"Querying with boolean logic"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#querying-with-boolean-logic","text":"","title":"Querying with boolean logic"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#adding-query-clauses-to-the-must-key","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } }, { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Adding query clauses to the must key"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#moving-the-range-query-to-the-filter-key","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Moving the range query to the filter key"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#adding-a-query-clause-to-the-must_not-key","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": \"tuna\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Adding a query clause to the must_not key"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#adding-a-query-clause-to-the-should-key","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ], \"must_not\": [ { \"match\": { \"ingredients.name\": \"tuna\" } } ], \"should\": [ { \"match\": { \"ingredients.name\": \"parsley\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Adding a query clause to the should key"},{"location":"Elastic_Stack/Adding%20Boolean%20Logic%20to%20Queries/querying-with-boolean-logic/#the-behavior-of-should-query-clauses-depends","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"ingredients.name\": \"pasta\" } } ], \"should\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ] } } } GET /recipe/_search { \"query\": { \"bool\": { \"should\": [ { \"match\": { \"ingredients.name\": \"parmesan\" } } ] } } }","title":"The behavior of should query clauses depends"},{"location":"Elastic_Stack/Aggregations/aggregating-nested-objects/","text":"Aggregating nested objects \u00b6 GET /department/_search { \"size\": 0, \"aggs\": { \"employees\": { \"nested\": { \"path\": \"employees\" } } } } GET /department/_search { \"size\": 0, \"aggs\": { \"employees\": { \"nested\": { \"path\": \"employees\" }, \"aggs\": { \"minimum_age\": { \"min\": { \"field\": \"employees.age\" } } } } } }","title":"Aggregating nested objects"},{"location":"Elastic_Stack/Aggregations/aggregating-nested-objects/#aggregating-nested-objects","text":"GET /department/_search { \"size\": 0, \"aggs\": { \"employees\": { \"nested\": { \"path\": \"employees\" } } } } GET /department/_search { \"size\": 0, \"aggs\": { \"employees\": { \"nested\": { \"path\": \"employees\" }, \"aggs\": { \"minimum_age\": { \"min\": { \"field\": \"employees.age\" } } } } } }","title":"Aggregating nested objects"},{"location":"Elastic_Stack/Aggregations/defining-bucket-rules-with-filters/","text":"Defining bucket rules with filters \u00b6 Placing documents into buckets based on criteria \u00b6 GET /recipe/_search { \"size\": 0, \"aggs\": { \"my_filter\": { \"filters\": { \"filters\": { \"pasta\": { \"match\": { \"title\": \"pasta\" } }, \"spaghetti\": { \"match\": { \"title\": \"spaghetti\" } } } } } } } Calculate average ratings for buckets \u00b6 GET /recipe/_search { \"size\": 0, \"aggs\": { \"my_filter\": { \"filters\": { \"filters\": { \"pasta\": { \"match\": { \"title\": \"pasta\" } }, \"spaghetti\": { \"match\": { \"title\": \"spaghetti\" } } } }, \"aggs\": { \"avg_rating\": { \"avg\": { \"field\": \"ratings\" } } } } } }","title":"Defining bucket rules with filters"},{"location":"Elastic_Stack/Aggregations/defining-bucket-rules-with-filters/#defining-bucket-rules-with-filters","text":"","title":"Defining bucket rules with filters"},{"location":"Elastic_Stack/Aggregations/defining-bucket-rules-with-filters/#placing-documents-into-buckets-based-on-criteria","text":"GET /recipe/_search { \"size\": 0, \"aggs\": { \"my_filter\": { \"filters\": { \"filters\": { \"pasta\": { \"match\": { \"title\": \"pasta\" } }, \"spaghetti\": { \"match\": { \"title\": \"spaghetti\" } } } } } } }","title":"Placing documents into buckets based on criteria"},{"location":"Elastic_Stack/Aggregations/defining-bucket-rules-with-filters/#calculate-average-ratings-for-buckets","text":"GET /recipe/_search { \"size\": 0, \"aggs\": { \"my_filter\": { \"filters\": { \"filters\": { \"pasta\": { \"match\": { \"title\": \"pasta\" } }, \"spaghetti\": { \"match\": { \"title\": \"spaghetti\" } } } }, \"aggs\": { \"avg_rating\": { \"avg\": { \"field\": \"ratings\" } } } } } }","title":"Calculate average ratings for buckets"},{"location":"Elastic_Stack/Aggregations/filtering-out-documents/","text":"Filtering out documents \u00b6 Filtering out documents with low total_amount \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"low_value\": { \"filter\": { \"range\": { \"total_amount\": { \"lt\": 50 } } } } } } Aggregating on the bucket of remaining documents \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"low_value\": { \"filter\": { \"range\": { \"total_amount\": { \"lt\": 50 } } }, \"aggs\": { \"avg_amount\": { \"avg\": { \"field\": \"total_amount\" } } } } } }","title":"Filtering out documents"},{"location":"Elastic_Stack/Aggregations/filtering-out-documents/#filtering-out-documents","text":"","title":"Filtering out documents"},{"location":"Elastic_Stack/Aggregations/filtering-out-documents/#filtering-out-documents-with-low-total_amount","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"low_value\": { \"filter\": { \"range\": { \"total_amount\": { \"lt\": 50 } } } } } }","title":"Filtering out documents with low total_amount"},{"location":"Elastic_Stack/Aggregations/filtering-out-documents/#aggregating-on-the-bucket-of-remaining-documents","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"low_value\": { \"filter\": { \"range\": { \"total_amount\": { \"lt\": 50 } } }, \"aggs\": { \"avg_amount\": { \"avg\": { \"field\": \"total_amount\" } } } } } }","title":"Aggregating on the bucket of remaining documents"},{"location":"Elastic_Stack/Aggregations/global-aggregation/","text":"global aggregation \u00b6 Break out of the aggregation context \u00b6 GET /orders/_search { \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"size\": 0, \"aggs\": { \"all_orders\": { \"global\": { }, \"aggs\": { \"stats_amount\": { \"stats\": { \"field\": \"total_amount\" } } } } } } Adding aggregation without global context \u00b6 GET /orders/_search { \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"size\": 0, \"aggs\": { \"all_orders\": { \"global\": { }, \"aggs\": { \"stats_amount\": { \"stats\": { \"field\": \"total_amount\" } } } }, \"stats_expensive\": { \"stats\": { \"field\": \"total_amount\" } } } }","title":"`global` aggregation"},{"location":"Elastic_Stack/Aggregations/global-aggregation/#global-aggregation","text":"","title":"global aggregation"},{"location":"Elastic_Stack/Aggregations/global-aggregation/#break-out-of-the-aggregation-context","text":"GET /orders/_search { \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"size\": 0, \"aggs\": { \"all_orders\": { \"global\": { }, \"aggs\": { \"stats_amount\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Break out of the aggregation context"},{"location":"Elastic_Stack/Aggregations/global-aggregation/#adding-aggregation-without-global-context","text":"GET /orders/_search { \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"size\": 0, \"aggs\": { \"all_orders\": { \"global\": { }, \"aggs\": { \"stats_amount\": { \"stats\": { \"field\": \"total_amount\" } } } }, \"stats_expensive\": { \"stats\": { \"field\": \"total_amount\" } } } }","title":"Adding aggregation without global context"},{"location":"Elastic_Stack/Aggregations/histograms/","text":"Histograms \u00b6 Distribution of total_amount with interval 25 \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25 } } } } Requiring minimum 1 document per bucket \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25, \"min_doc_count\": 1 } } } } Specifying fixed bucket boundaries \u00b6 GET /orders/_search { \"size\": 0, \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25, \"min_doc_count\": 0, \"extended_bounds\": { \"min\": 0, \"max\": 500 } } } } } Aggregating by month with the date_histogram aggregation \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_over_time\": { \"date_histogram\": { \"field\": \"purchased_at\", \"calendar_interval\": \"month\" } } } }","title":"Histograms"},{"location":"Elastic_Stack/Aggregations/histograms/#histograms","text":"","title":"Histograms"},{"location":"Elastic_Stack/Aggregations/histograms/#distribution-of-total_amount-with-interval-25","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25 } } } }","title":"Distribution of total_amount with interval 25"},{"location":"Elastic_Stack/Aggregations/histograms/#requiring-minimum-1-document-per-bucket","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25, \"min_doc_count\": 1 } } } }","title":"Requiring minimum 1 document per bucket"},{"location":"Elastic_Stack/Aggregations/histograms/#specifying-fixed-bucket-boundaries","text":"GET /orders/_search { \"size\": 0, \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"aggs\": { \"amount_distribution\": { \"histogram\": { \"field\": \"total_amount\", \"interval\": 25, \"min_doc_count\": 0, \"extended_bounds\": { \"min\": 0, \"max\": 500 } } } } }","title":"Specifying fixed bucket boundaries"},{"location":"Elastic_Stack/Aggregations/histograms/#aggregating-by-month-with-the-date_histogram-aggregation","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_over_time\": { \"date_histogram\": { \"field\": \"purchased_at\", \"calendar_interval\": \"month\" } } } }","title":"Aggregating by month with the date_histogram aggregation"},{"location":"Elastic_Stack/Aggregations/introduction-to-aggregations/","text":"Introduction to aggregations \u00b6 Adding orders index with field mappings \u00b6 PUT /orders { \"mappings\": { \"properties\": { \"purchased_at\": { \"type\": \"date\" }, \"lines\": { \"type\": \"nested\", \"properties\": { \"product_id\": { \"type\": \"integer\" }, \"amount\": { \"type\": \"double\" }, \"quantity\": { \"type\": \"short\" } } }, \"total_amount\": { \"type\": \"double\" }, \"status\": { \"type\": \"keyword\" }, \"sales_channel\": { \"type\": \"keyword\" }, \"salesman\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\" }, \"name\": { \"type\": \"text\" } } } } } } Populating the orders index with test data \u00b6 curl -H \"Content-Type:application/x-ndjson\" -XPOST 'http://localhost:9200/orders/_bulk' --data-binary \"@orders-bulk.json\"","title":"Introduction to aggregations"},{"location":"Elastic_Stack/Aggregations/introduction-to-aggregations/#introduction-to-aggregations","text":"","title":"Introduction to aggregations"},{"location":"Elastic_Stack/Aggregations/introduction-to-aggregations/#adding-orders-index-with-field-mappings","text":"PUT /orders { \"mappings\": { \"properties\": { \"purchased_at\": { \"type\": \"date\" }, \"lines\": { \"type\": \"nested\", \"properties\": { \"product_id\": { \"type\": \"integer\" }, \"amount\": { \"type\": \"double\" }, \"quantity\": { \"type\": \"short\" } } }, \"total_amount\": { \"type\": \"double\" }, \"status\": { \"type\": \"keyword\" }, \"sales_channel\": { \"type\": \"keyword\" }, \"salesman\": { \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"integer\" }, \"name\": { \"type\": \"text\" } } } } } }","title":"Adding orders index with field mappings"},{"location":"Elastic_Stack/Aggregations/introduction-to-aggregations/#populating-the-orders-index-with-test-data","text":"curl -H \"Content-Type:application/x-ndjson\" -XPOST 'http://localhost:9200/orders/_bulk' --data-binary \"@orders-bulk.json\"","title":"Populating the orders index with test data"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/","text":"Introduction to bucket aggregations \u00b6 Creating a bucket for each status value \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\" } } } } Including 20 terms instead of the default 10 \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20 } } } } Aggregating documents with missing field (or NULL ) \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\" } } } } Changing the minimum document count for a bucket to be created \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\", \"min_doc_count\": 0 } } } } Ordering the buckets \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\", \"min_doc_count\": 0, \"order\": { \"_key\": \"asc\" } } } } }","title":"Introduction to bucket aggregations"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#introduction-to-bucket-aggregations","text":"","title":"Introduction to bucket aggregations"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#creating-a-bucket-for-each-status-value","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\" } } } }","title":"Creating a bucket for each status value"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#including-20-terms-instead-of-the-default-10","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20 } } } }","title":"Including 20 terms instead of the default 10"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#aggregating-documents-with-missing-field-or-null","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\" } } } }","title":"Aggregating documents with missing field (or NULL)"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#changing-the-minimum-document-count-for-a-bucket-to-be-created","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\", \"min_doc_count\": 0 } } } }","title":"Changing the minimum document count for a bucket to be created"},{"location":"Elastic_Stack/Aggregations/introduction-to-bucket-aggregations/#ordering-the-buckets","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status.keyword\", \"size\": 20, \"missing\": \"N/A\", \"min_doc_count\": 0, \"order\": { \"_key\": \"asc\" } } } } }","title":"Ordering the buckets"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/","text":"Metric aggregations \u00b6 Calculating statistics with sum , avg , min , and max aggregations \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"total_sales\": { \"sum\": { \"field\": \"total_amount\" } }, \"avg_sale\": { \"avg\": { \"field\": \"total_amount\" } }, \"min_sale\": { \"min\": { \"field\": \"total_amount\" } }, \"max_sale\": { \"max\": { \"field\": \"total_amount\" } } } } Retrieving the number of distinct values \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"total_salesmen\": { \"cardinality\": { \"field\": \"salesman.id\" } } } } Retrieving the number of values \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"values_count\": { \"value_count\": { \"field\": \"total_amount\" } } } } Using stats aggregation for common statistics \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_stats\": { \"stats\": { \"field\": \"total_amount\" } } } }","title":"Metric aggregations"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/#metric-aggregations","text":"","title":"Metric aggregations"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/#calculating-statistics-with-sum-avg-min-and-max-aggregations","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"total_sales\": { \"sum\": { \"field\": \"total_amount\" } }, \"avg_sale\": { \"avg\": { \"field\": \"total_amount\" } }, \"min_sale\": { \"min\": { \"field\": \"total_amount\" } }, \"max_sale\": { \"max\": { \"field\": \"total_amount\" } } } }","title":"Calculating statistics with sum, avg, min, and max aggregations"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/#retrieving-the-number-of-distinct-values","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"total_salesmen\": { \"cardinality\": { \"field\": \"salesman.id\" } } } }","title":"Retrieving the number of distinct values"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/#retrieving-the-number-of-values","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"values_count\": { \"value_count\": { \"field\": \"total_amount\" } } } }","title":"Retrieving the number of values"},{"location":"Elastic_Stack/Aggregations/metric-aggregations/#using-stats-aggregation-for-common-statistics","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_stats\": { \"stats\": { \"field\": \"total_amount\" } } } }","title":"Using stats aggregation for common statistics"},{"location":"Elastic_Stack/Aggregations/missing-field-values/","text":"Missing field values \u00b6 Adding test documents \u00b6 PUT /orders/_doc/1001 { \"total_amount\": 100 } PUT /orders/_doc/1002 { \"total_amount\": 200, \"status\": null } Aggregating documents with missing field value \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_without_status\": { \"missing\": { \"field\": \"status.keyword\" } } } } Combining missing aggregation with other aggregations \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_without_status\": { \"missing\": { \"field\": \"status.keyword\" }, \"aggs\": { \"missing_sum\": { \"sum\": { \"field\": \"total_amount\" } } } } } } Deleting test documents \u00b6 DELETE /orders/_doc/1001 DELETE /orders/_doc/1002","title":"Missing field values"},{"location":"Elastic_Stack/Aggregations/missing-field-values/#missing-field-values","text":"","title":"Missing field values"},{"location":"Elastic_Stack/Aggregations/missing-field-values/#adding-test-documents","text":"PUT /orders/_doc/1001 { \"total_amount\": 100 } PUT /orders/_doc/1002 { \"total_amount\": 200, \"status\": null }","title":"Adding test documents"},{"location":"Elastic_Stack/Aggregations/missing-field-values/#aggregating-documents-with-missing-field-value","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_without_status\": { \"missing\": { \"field\": \"status.keyword\" } } } }","title":"Aggregating documents with missing field value"},{"location":"Elastic_Stack/Aggregations/missing-field-values/#combining-missing-aggregation-with-other-aggregations","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"orders_without_status\": { \"missing\": { \"field\": \"status.keyword\" }, \"aggs\": { \"missing_sum\": { \"sum\": { \"field\": \"total_amount\" } } } } } }","title":"Combining missing aggregation with other aggregations"},{"location":"Elastic_Stack/Aggregations/missing-field-values/#deleting-test-documents","text":"DELETE /orders/_doc/1001 DELETE /orders/_doc/1002","title":"Deleting test documents"},{"location":"Elastic_Stack/Aggregations/nested-aggregations/","text":"Nested aggregations \u00b6 Retrieving statistics for each status \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status\" }, \"aggs\": { \"status_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } } Narrowing down the aggregation context \u00b6 GET /orders/_search { \"size\": 0, \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status\" }, \"aggs\": { \"status_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Nested aggregations"},{"location":"Elastic_Stack/Aggregations/nested-aggregations/#nested-aggregations","text":"","title":"Nested aggregations"},{"location":"Elastic_Stack/Aggregations/nested-aggregations/#retrieving-statistics-for-each-status","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status\" }, \"aggs\": { \"status_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Retrieving statistics for each status"},{"location":"Elastic_Stack/Aggregations/nested-aggregations/#narrowing-down-the-aggregation-context","text":"GET /orders/_search { \"size\": 0, \"query\": { \"range\": { \"total_amount\": { \"gte\": 100 } } }, \"aggs\": { \"status_terms\": { \"terms\": { \"field\": \"status\" }, \"aggs\": { \"status_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Narrowing down the aggregation context"},{"location":"Elastic_Stack/Aggregations/range-aggregations/","text":"Range aggregations \u00b6 range aggregation \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"range\": { \"field\": \"total_amount\", \"ranges\": [ { \"to\": 50 }, { \"from\": 50, \"to\": 100 }, { \"from\": 100 } ] } } } } date_range aggregation \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } } Specifying the date format \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } } Enabling keys for the buckets \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } } Defining the bucket keys \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\", \"key\": \"first_half\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\", \"key\": \"second_half\" } ] } } } } Adding a sub-aggregation \u00b6 GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\", \"key\": \"first_half\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\", \"key\": \"second_half\" } ] }, \"aggs\": { \"bucket_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Range aggregations"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#range-aggregations","text":"","title":"Range aggregations"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#range-aggregation","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"amount_distribution\": { \"range\": { \"field\": \"total_amount\", \"ranges\": [ { \"to\": 50 }, { \"from\": 50, \"to\": 100 }, { \"from\": 100 } ] } } } }","title":"range aggregation"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#date_range-aggregation","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } }","title":"date_range aggregation"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#specifying-the-date-format","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } }","title":"Specifying the date format"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#enabling-keys-for-the-buckets","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\" } ] } } } }","title":"Enabling keys for the buckets"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#defining-the-bucket-keys","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\", \"key\": \"first_half\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\", \"key\": \"second_half\" } ] } } } }","title":"Defining the bucket keys"},{"location":"Elastic_Stack/Aggregations/range-aggregations/#adding-a-sub-aggregation","text":"GET /orders/_search { \"size\": 0, \"aggs\": { \"purchased_ranges\": { \"date_range\": { \"field\": \"purchased_at\", \"format\": \"yyyy-MM-dd\", \"keyed\": true, \"ranges\": [ { \"from\": \"2016-01-01\", \"to\": \"2016-01-01||+6M\", \"key\": \"first_half\" }, { \"from\": \"2016-01-01||+6M\", \"to\": \"2016-01-01||+1y\", \"key\": \"second_half\" } ] }, \"aggs\": { \"bucket_stats\": { \"stats\": { \"field\": \"total_amount\" } } } } } }","title":"Adding a sub-aggregation"},{"location":"Elastic_Stack/Controlling%20Query%20Results/filters/","text":"Filters \u00b6 Adding a filter clause to the bool query \u00b6 GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": \"pasta\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Filters"},{"location":"Elastic_Stack/Controlling%20Query%20Results/filters/#filters","text":"","title":"Filters"},{"location":"Elastic_Stack/Controlling%20Query%20Results/filters/#adding-a-filter-clause-to-the-bool-query","text":"GET /recipe/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": \"pasta\" } } ], \"filter\": [ { \"range\": { \"preparation_time_minutes\": { \"lte\": 15 } } } ] } } }","title":"Adding a filter clause to the bool query"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-by-multi-value-fields/","text":"Sorting by multi-value fields \u00b6 Sorting by the average rating (descending) \u00b6 GET /recipe/_search { \"_source\": \"ratings\", \"query\": { \"match_all\": {} }, \"sort\": [ { \"ratings\": { \"order\": \"desc\", \"mode\": \"avg\" } } ] }","title":"Sorting by multi-value fields"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-by-multi-value-fields/#sorting-by-multi-value-fields","text":"","title":"Sorting by multi-value fields"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-by-multi-value-fields/#sorting-by-the-average-rating-descending","text":"GET /recipe/_search { \"_source\": \"ratings\", \"query\": { \"match_all\": {} }, \"sort\": [ { \"ratings\": { \"order\": \"desc\", \"mode\": \"avg\" } } ] }","title":"Sorting by the average rating (descending)"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-results/","text":"Sorting results \u00b6 Sorting by ascending order (implicitly) \u00b6 GET /recipe/_search { \"_source\": false, \"query\": { \"match_all\": {} }, \"sort\": [ \"preparation_time_minutes\" ] } Sorting by descending order \u00b6 GET /recipe/_search { \"_source\": \"created\", \"query\": { \"match_all\": {} }, \"sort\": [ { \"created\": \"desc\" } ] } Sorting by multiple fields \u00b6 GET /recipe/_search { \"_source\": [ \"preparation_time_minutes\", \"created\" ], \"query\": { \"match_all\": {} }, \"sort\": [ { \"preparation_time_minutes\": \"asc\" }, { \"created\": \"desc\" } ] }","title":"Sorting results"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-results/#sorting-results","text":"","title":"Sorting results"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-results/#sorting-by-ascending-order-implicitly","text":"GET /recipe/_search { \"_source\": false, \"query\": { \"match_all\": {} }, \"sort\": [ \"preparation_time_minutes\" ] }","title":"Sorting by ascending order (implicitly)"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-results/#sorting-by-descending-order","text":"GET /recipe/_search { \"_source\": \"created\", \"query\": { \"match_all\": {} }, \"sort\": [ { \"created\": \"desc\" } ] }","title":"Sorting by descending order"},{"location":"Elastic_Stack/Controlling%20Query%20Results/sorting-results/#sorting-by-multiple-fields","text":"GET /recipe/_search { \"_source\": [ \"preparation_time_minutes\", \"created\" ], \"query\": { \"match_all\": {} }, \"sort\": [ { \"preparation_time_minutes\": \"asc\" }, { \"created\": \"desc\" } ] }","title":"Sorting by multiple fields"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/","text":"Source filtering \u00b6 Excluding the _source field altogether \u00b6 GET /recipe/_search { \"_source\": false, \"query\": { \"match\": { \"title\": \"pasta\" } } } Only returning the created field \u00b6 GET /recipe/_search { \"_source\": \"created\", \"query\": { \"match\": { \"title\": \"pasta\" } } } Only returning an object's key \u00b6 GET /recipe/_search { \"_source\": \"ingredients.name\", \"query\": { \"match\": { \"title\": \"pasta\" } } } Returning all of an object's keys \u00b6 GET /recipe/_search { \"_source\": \"ingredients.*\", \"query\": { \"match\": { \"title\": \"pasta\" } } } Returning the ingredients object with all keys, and the servings field \u00b6 GET /recipe/_search { \"_source\": [ \"ingredients.*\", \"servings\" ], \"query\": { \"match\": { \"title\": \"pasta\" } } } Including all of the ingredients object's keys, except the name key \u00b6 GET /recipe/_search { \"_source\": { \"includes\": \"ingredients.*\", \"excludes\": \"ingredients.name\" }, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Source filtering"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#source-filtering","text":"","title":"Source filtering"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#excluding-the-_source-field-altogether","text":"GET /recipe/_search { \"_source\": false, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Excluding the _source field altogether"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#only-returning-the-created-field","text":"GET /recipe/_search { \"_source\": \"created\", \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Only returning the created field"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#only-returning-an-objects-key","text":"GET /recipe/_search { \"_source\": \"ingredients.name\", \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Only returning an object's key"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#returning-all-of-an-objects-keys","text":"GET /recipe/_search { \"_source\": \"ingredients.*\", \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Returning all of an object's keys"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#returning-the-ingredients-object-with-all-keys-and-the-servings-field","text":"GET /recipe/_search { \"_source\": [ \"ingredients.*\", \"servings\" ], \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Returning the ingredients object with all keys, and the servings field"},{"location":"Elastic_Stack/Controlling%20Query%20Results/source-filtering/#including-all-of-the-ingredients-objects-keys-except-the-name-key","text":"GET /recipe/_search { \"_source\": { \"includes\": \"ingredients.*\", \"excludes\": \"ingredients.name\" }, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Including all of the ingredients object's keys, except the name key"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-an-offset/","text":"Specifying an offset \u00b6 Specifying an offset with the from parameter \u00b6 GET /recipe/_search { \"_source\": false, \"size\": 2, \"from\": 2, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Specifying an offset"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-an-offset/#specifying-an-offset","text":"","title":"Specifying an offset"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-an-offset/#specifying-an-offset-with-the-from-parameter","text":"GET /recipe/_search { \"_source\": false, \"size\": 2, \"from\": 2, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Specifying an offset with the from parameter"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-format/","text":"Specifying the result format \u00b6 Returning results as YAML \u00b6 GET /recipe/_search?format=yaml { \"query\": { \"match\": { \"title\": \"pasta\" } } } Returning pretty JSON \u00b6 GET /recipe/_search?pretty { \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Specifying the result format"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-format/#specifying-the-result-format","text":"","title":"Specifying the result format"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-format/#returning-results-as-yaml","text":"GET /recipe/_search?format=yaml { \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Returning results as YAML"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-format/#returning-pretty-json","text":"GET /recipe/_search?pretty { \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Returning pretty JSON"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-size/","text":"Specifying the result size \u00b6 Using a query parameter \u00b6 GET /recipe/_search?size=2 { \"_source\": false, \"query\": { \"match\": { \"title\": \"pasta\" } } } Using a parameter within the request body \u00b6 GET /recipe/_search { \"_source\": false, \"size\": 2, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Specifying the result size"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-size/#specifying-the-result-size","text":"","title":"Specifying the result size"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-size/#using-a-query-parameter","text":"GET /recipe/_search?size=2 { \"_source\": false, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Using a query parameter"},{"location":"Elastic_Stack/Controlling%20Query%20Results/specifying-the-result-size/#using-a-parameter-within-the-request-body","text":"GET /recipe/_search { \"_source\": false, \"size\": 2, \"query\": { \"match\": { \"title\": \"pasta\" } } }","title":"Using a parameter within the request body"},{"location":"Elastic_Stack/Full%20Text%20Queries/exercises/","text":"Exercises \u00b6 GET /recipe/_search { \"query\": { \"match\": { \"title\": \"Pasta with parmesan and spinach\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"pasta carbonara\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"carbonara pasta\" } } } GET /recipe/_search { \"query\": { \"multi_match\": { \"query\": \"pasta pesto\", \"fields\": [ \"title\", \"description\" ] } } }","title":"Exercises"},{"location":"Elastic_Stack/Full%20Text%20Queries/exercises/#exercises","text":"GET /recipe/_search { \"query\": { \"match\": { \"title\": \"Pasta with parmesan and spinach\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"pasta carbonara\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"carbonara pasta\" } } } GET /recipe/_search { \"query\": { \"multi_match\": { \"query\": \"pasta pesto\", \"fields\": [ \"title\", \"description\" ] } } }","title":"Exercises"},{"location":"Elastic_Stack/Full%20Text%20Queries/flexible-matching-with-match-query/","text":"Flexible matching with match query \u00b6 Standard match query \u00b6 GET /recipe/_search { \"query\": { \"match\": { \"title\": \"Recipes with pasta or spaghetti\" } } } Specifying a boolean operator \u00b6 GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"Recipes with pasta or spaghetti\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta or spaghetti\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta spaghetti\", \"operator\": \"and\" } } } }","title":"Flexible matching with `match` query"},{"location":"Elastic_Stack/Full%20Text%20Queries/flexible-matching-with-match-query/#flexible-matching-with-match-query","text":"","title":"Flexible matching with match query"},{"location":"Elastic_Stack/Full%20Text%20Queries/flexible-matching-with-match-query/#standard-match-query","text":"GET /recipe/_search { \"query\": { \"match\": { \"title\": \"Recipes with pasta or spaghetti\" } } }","title":"Standard match query"},{"location":"Elastic_Stack/Full%20Text%20Queries/flexible-matching-with-match-query/#specifying-a-boolean-operator","text":"GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"Recipes with pasta or spaghetti\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta or spaghetti\", \"operator\": \"and\" } } } } GET /recipe/_search { \"query\": { \"match\": { \"title\": { \"query\": \"pasta spaghetti\", \"operator\": \"and\" } } } }","title":"Specifying a boolean operator"},{"location":"Elastic_Stack/Full%20Text%20Queries/introduction-to-full-text-queries/","text":"Introduction to full text queries \u00b6 Importing new test data \u00b6 cd /path/to/data/file/directory curl -H \"Content-Type: application/x-ndjson\" -XPOST \"http://localhost:9200/recipe/_bulk?pretty\" --data-binary \"@recipes-bulk.json\" Inspecting the mapping \u00b6 GET /recipe/_mapping","title":"Introduction to full text queries"},{"location":"Elastic_Stack/Full%20Text%20Queries/introduction-to-full-text-queries/#introduction-to-full-text-queries","text":"","title":"Introduction to full text queries"},{"location":"Elastic_Stack/Full%20Text%20Queries/introduction-to-full-text-queries/#importing-new-test-data","text":"cd /path/to/data/file/directory curl -H \"Content-Type: application/x-ndjson\" -XPOST \"http://localhost:9200/recipe/_bulk?pretty\" --data-binary \"@recipes-bulk.json\"","title":"Importing new test data"},{"location":"Elastic_Stack/Full%20Text%20Queries/introduction-to-full-text-queries/#inspecting-the-mapping","text":"GET /recipe/_mapping","title":"Inspecting the mapping"},{"location":"Elastic_Stack/Full%20Text%20Queries/matching-phrases/","text":"Matching phrases \u00b6 The order of terms matters \u00b6 GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"spaghetti puttanesca\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"puttanesca spaghetti\" } } }","title":"Matching phrases"},{"location":"Elastic_Stack/Full%20Text%20Queries/matching-phrases/#matching-phrases","text":"","title":"Matching phrases"},{"location":"Elastic_Stack/Full%20Text%20Queries/matching-phrases/#the-order-of-terms-matters","text":"GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"spaghetti puttanesca\" } } } GET /recipe/_search { \"query\": { \"match_phrase\": { \"title\": \"puttanesca spaghetti\" } } }","title":"The order of terms matters"},{"location":"Elastic_Stack/Full%20Text%20Queries/searching-multiple-fields/","text":"Searching multiple fields \u00b6 GET /recipe/_search { \"query\": { \"multi_match\": { \"query\": \"pasta\", \"fields\": [ \"title\", \"description\" ] } } }","title":"Searching multiple fields"},{"location":"Elastic_Stack/Full%20Text%20Queries/searching-multiple-fields/#searching-multiple-fields","text":"GET /recipe/_search { \"query\": { \"multi_match\": { \"query\": \"pasta\", \"fields\": [ \"title\", \"description\" ] } } }","title":"Searching multiple fields"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms-from-file/","text":"Adding synonyms from file \u00b6 Adding index with custom analyzer \u00b6 PUT /synonyms { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms_path\": \"analysis/synonyms.txt\" } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } } Synonyms file ( config/analysis/synonyms.txt ) \u00b6 # This is a comment awful => terrible awesome => great, super elasticsearch, logstash, kibana => elk weird, strange Testing the analyzer \u00b6 POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch\" }","title":"Adding synonyms from file"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms-from-file/#adding-synonyms-from-file","text":"","title":"Adding synonyms from file"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms-from-file/#adding-index-with-custom-analyzer","text":"PUT /synonyms { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms_path\": \"analysis/synonyms.txt\" } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } }","title":"Adding index with custom analyzer"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms-from-file/#synonyms-file-configanalysissynonymstxt","text":"# This is a comment awful => terrible awesome => great, super elasticsearch, logstash, kibana => elk weird, strange","title":"Synonyms file (config/analysis/synonyms.txt)"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms-from-file/#testing-the-analyzer","text":"POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch\" }","title":"Testing the analyzer"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/","text":"Adding synonyms \u00b6 Creating index with custom analyzer \u00b6 PUT /synonyms { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms\": [ \"awful => terrible\", \"awesome => great, super\", \"elasticsearch, logstash, kibana => elk\", \"weird, strange\" ] } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } } Testing the analyzer (with synonyms) \u00b6 POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"awesome\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"weird\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch is awesome, but can also seem weird sometimes.\" } Adding a test document \u00b6 POST /synonyms/_doc { \"description\": \"Elasticsearch is awesome, but can also seem weird sometimes.\" } Searching the index for synonyms \u00b6 GET /synonyms/_search { \"query\": { \"match\": { \"description\": \"great\" } } } GET /synonyms/_search { \"query\": { \"match\": { \"description\": \"awesome\" } } }","title":"Adding synonyms"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/#adding-synonyms","text":"","title":"Adding synonyms"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/#creating-index-with-custom-analyzer","text":"PUT /synonyms { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms\": [ \"awful => terrible\", \"awesome => great, super\", \"elasticsearch, logstash, kibana => elk\", \"weird, strange\" ] } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } }","title":"Creating index with custom analyzer"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/#testing-the-analyzer-with-synonyms","text":"POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"awesome\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"weird\" } POST /synonyms/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"Elasticsearch is awesome, but can also seem weird sometimes.\" }","title":"Testing the analyzer (with synonyms)"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/#adding-a-test-document","text":"POST /synonyms/_doc { \"description\": \"Elasticsearch is awesome, but can also seem weird sometimes.\" }","title":"Adding a test document"},{"location":"Elastic_Stack/Improving%20Search%20Results/adding-synonyms/#searching-the-index-for-synonyms","text":"GET /synonyms/_search { \"query\": { \"match\": { \"description\": \"great\" } } } GET /synonyms/_search { \"query\": { \"match\": { \"description\": \"awesome\" } } }","title":"Searching the index for synonyms"},{"location":"Elastic_Stack/Improving%20Search%20Results/affecting-relevance-scoring-with-proximity/","text":"Affecting relevance scoring with proximity \u00b6 A simple match query within a bool query \u00b6 GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ] } } } Boosting relevance based on proximity \u00b6 GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ], \"should\": [ { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\" } } } ] } } } Adding the slop parameter \u00b6 GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ], \"should\": [ { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 5 } } } ] } } }","title":"Affecting relevance scoring with proximity"},{"location":"Elastic_Stack/Improving%20Search%20Results/affecting-relevance-scoring-with-proximity/#affecting-relevance-scoring-with-proximity","text":"","title":"Affecting relevance scoring with proximity"},{"location":"Elastic_Stack/Improving%20Search%20Results/affecting-relevance-scoring-with-proximity/#a-simple-match-query-within-a-bool-query","text":"GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ] } } }","title":"A simple match query within a bool query"},{"location":"Elastic_Stack/Improving%20Search%20Results/affecting-relevance-scoring-with-proximity/#boosting-relevance-based-on-proximity","text":"GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ], \"should\": [ { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\" } } } ] } } }","title":"Boosting relevance based on proximity"},{"location":"Elastic_Stack/Improving%20Search%20Results/affecting-relevance-scoring-with-proximity/#adding-the-slop-parameter","text":"GET /proximity/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": { \"query\": \"spicy sauce\" } } } ], \"should\": [ { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 5 } } } ] } } }","title":"Adding the slop parameter"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/","text":"Fuzzy match query \u00b6 Searching with fuzziness set to auto \u00b6 GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"l0bster\", \"fuzziness\": \"auto\" } } } } GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lobster\", \"fuzziness\": \"auto\" } } } } Fuzziness is per term (and specifying an integer) \u00b6 GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"l0bster love\", \"operator\": \"and\", \"fuzziness\": 1 } } } } Switching letters around with transpositions \u00b6 GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lvie\", \"fuzziness\": 1 } } } } Disabling transpositions \u00b6 GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lvie\", \"fuzziness\": 1, \"fuzzy_transpositions\": false } } } }","title":"Fuzzy `match` query"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/#fuzzy-match-query","text":"","title":"Fuzzy match query"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/#searching-with-fuzziness-set-to-auto","text":"GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"l0bster\", \"fuzziness\": \"auto\" } } } } GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lobster\", \"fuzziness\": \"auto\" } } } }","title":"Searching with fuzziness set to auto"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/#fuzziness-is-per-term-and-specifying-an-integer","text":"GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"l0bster love\", \"operator\": \"and\", \"fuzziness\": 1 } } } }","title":"Fuzziness is per term (and specifying an integer)"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/#switching-letters-around-with-transpositions","text":"GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lvie\", \"fuzziness\": 1 } } } }","title":"Switching letters around with transpositions"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-match-query/#disabling-transpositions","text":"GET /products/_search { \"query\": { \"match\": { \"name\": { \"query\": \"lvie\", \"fuzziness\": 1, \"fuzzy_transpositions\": false } } } }","title":"Disabling transpositions"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-query/","text":"fuzzy query \u00b6 GET /products/_search { \"query\": { \"fuzzy\": { \"name\": { \"value\": \"LOBSTER\", \"fuzziness\": \"auto\" } } } } GET /products/_search { \"query\": { \"fuzzy\": { \"name\": { \"value\": \"lobster\", \"fuzziness\": \"auto\" } } } }","title":"`fuzzy` query"},{"location":"Elastic_Stack/Improving%20Search%20Results/fuzzy-query/#fuzzy-query","text":"GET /products/_search { \"query\": { \"fuzzy\": { \"name\": { \"value\": \"LOBSTER\", \"fuzziness\": \"auto\" } } } } GET /products/_search { \"query\": { \"fuzzy\": { \"name\": { \"value\": \"lobster\", \"fuzziness\": \"auto\" } } } }","title":"fuzzy query"},{"location":"Elastic_Stack/Improving%20Search%20Results/highlighting-matches-in-fields/","text":"Highlighting matches in fields \u00b6 Adding a test document \u00b6 PUT /highlighting/_doc/1 { \"description\": \"Let me tell you a story about Elasticsearch. It's a full-text search engine that is built on Apache Lucene. It's really easy to use, but also packs lots of advanced features that you can use to tweak its searching capabilities. Lots of well-known and established companies use Elasticsearch, and so should you!\" } Highlighting matches within the description field \u00b6 GET /highlighting/_search { \"_source\": false, \"query\": { \"match\": { \"description\": \"Elasticsearch story\" } }, \"highlight\": { \"fields\": { \"description\" : {} } } } Specifying a custom tag \u00b6 GET /highlighting/_search { \"_source\": false, \"query\": { \"match\": { \"description\": \"Elasticsearch story\" } }, \"highlight\": { \"pre_tags\": [ \"<strong>\" ], \"post_tags\": [ \"</strong>\" ], \"fields\": { \"description\" : {} } } }","title":"Highlighting matches in fields"},{"location":"Elastic_Stack/Improving%20Search%20Results/highlighting-matches-in-fields/#highlighting-matches-in-fields","text":"","title":"Highlighting matches in fields"},{"location":"Elastic_Stack/Improving%20Search%20Results/highlighting-matches-in-fields/#adding-a-test-document","text":"PUT /highlighting/_doc/1 { \"description\": \"Let me tell you a story about Elasticsearch. It's a full-text search engine that is built on Apache Lucene. It's really easy to use, but also packs lots of advanced features that you can use to tweak its searching capabilities. Lots of well-known and established companies use Elasticsearch, and so should you!\" }","title":"Adding a test document"},{"location":"Elastic_Stack/Improving%20Search%20Results/highlighting-matches-in-fields/#highlighting-matches-within-the-description-field","text":"GET /highlighting/_search { \"_source\": false, \"query\": { \"match\": { \"description\": \"Elasticsearch story\" } }, \"highlight\": { \"fields\": { \"description\" : {} } } }","title":"Highlighting matches within the description field"},{"location":"Elastic_Stack/Improving%20Search%20Results/highlighting-matches-in-fields/#specifying-a-custom-tag","text":"GET /highlighting/_search { \"_source\": false, \"query\": { \"match\": { \"description\": \"Elasticsearch story\" } }, \"highlight\": { \"pre_tags\": [ \"<strong>\" ], \"post_tags\": [ \"</strong>\" ], \"fields\": { \"description\" : {} } } }","title":"Specifying a custom tag"},{"location":"Elastic_Stack/Improving%20Search%20Results/proximity-searches/","text":"Proximity searches \u00b6 Adding test documents \u00b6 PUT /proximity/_doc/1 { \"title\": \"Spicy Sauce\" } PUT /proximity/_doc/2 { \"title\": \"Spicy Tomato Sauce\" } PUT /proximity/_doc/3 { \"title\": \"Spicy Tomato and Garlic Sauce\" } PUT /proximity/_doc/4 { \"title\": \"Tomato Sauce (spicy)\" } PUT /proximity/_doc/5 { \"title\": \"Spicy and very delicious Tomato Sauce\" } Adding the slop parameter to a match_phrase query \u00b6 GET /proximity/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 1 } } } } GET /proximity/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 2 } } } }","title":"Proximity searches"},{"location":"Elastic_Stack/Improving%20Search%20Results/proximity-searches/#proximity-searches","text":"","title":"Proximity searches"},{"location":"Elastic_Stack/Improving%20Search%20Results/proximity-searches/#adding-test-documents","text":"PUT /proximity/_doc/1 { \"title\": \"Spicy Sauce\" } PUT /proximity/_doc/2 { \"title\": \"Spicy Tomato Sauce\" } PUT /proximity/_doc/3 { \"title\": \"Spicy Tomato and Garlic Sauce\" } PUT /proximity/_doc/4 { \"title\": \"Tomato Sauce (spicy)\" } PUT /proximity/_doc/5 { \"title\": \"Spicy and very delicious Tomato Sauce\" }","title":"Adding test documents"},{"location":"Elastic_Stack/Improving%20Search%20Results/proximity-searches/#adding-the-slop-parameter-to-a-match_phrase-query","text":"GET /proximity/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 1 } } } } GET /proximity/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"spicy sauce\", \"slop\": 2 } } } }","title":"Adding the slop parameter to a match_phrase query"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/","text":"Stemming \u00b6 Creating a test index \u00b6 PUT /stemming_test { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms\": [ \"firm => company\", \"love, enjoy\" ] }, \"stemmer_test\" : { \"type\" : \"stemmer\", \"name\" : \"english\" } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\", \"stemmer_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } } Adding a test document \u00b6 PUT /stemming_test/_doc/1 { \"description\": \"I love working for my firm!\" } Matching the document with the base word ( work ) \u00b6 GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"enjoy work\" } } } The query is stemmed, so the document still matches \u00b6 GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"love working\" } } } Synonyms and stemmed words are still highlighted \u00b6 GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"enjoy work\" } }, \"highlight\": { \"fields\": { \"description\": {} } } }","title":"Stemming"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#stemming","text":"","title":"Stemming"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#creating-a-test-index","text":"PUT /stemming_test { \"settings\": { \"analysis\": { \"filter\": { \"synonym_test\": { \"type\": \"synonym\", \"synonyms\": [ \"firm => company\", \"love, enjoy\" ] }, \"stemmer_test\" : { \"type\" : \"stemmer\", \"name\" : \"english\" } }, \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"synonym_test\", \"stemmer_test\" ] } } } }, \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_analyzer\" } } } }","title":"Creating a test index"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#adding-a-test-document","text":"PUT /stemming_test/_doc/1 { \"description\": \"I love working for my firm!\" }","title":"Adding a test document"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#matching-the-document-with-the-base-word-work","text":"GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"enjoy work\" } } }","title":"Matching the document with the base word (work)"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#the-query-is-stemmed-so-the-document-still-matches","text":"GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"love working\" } } }","title":"The query is stemmed, so the document still matches"},{"location":"Elastic_Stack/Improving%20Search%20Results/stemming/#synonyms-and-stemmed-words-are-still-highlighted","text":"GET /stemming_test/_search { \"query\": { \"match\": { \"description\": \"enjoy work\" } }, \"highlight\": { \"fields\": { \"description\": {} } } }","title":"Synonyms and stemmed words are still highlighted"},{"location":"Elastic_Stack/Introduction%20to%20Searching/debugging-unexpected-query-results/","text":"Debugging unexpected query results \u00b6 GET /products/_doc/1/_explain { \"query\": { \"term\": { \"name\": \"lobster\" } } }","title":"Debugging unexpected query results"},{"location":"Elastic_Stack/Introduction%20to%20Searching/debugging-unexpected-query-results/#debugging-unexpected-query-results","text":"GET /products/_doc/1/_explain { \"query\": { \"term\": { \"name\": \"lobster\" } } }","title":"Debugging unexpected query results"},{"location":"Elastic_Stack/Introduction%20to%20Searching/full-text-queries-vs-term-level-queries/","text":"Full text queries vs term level queries \u00b6 Term level queries are not analyzed \u00b6 GET /products/_search { \"query\": { \"term\": { \"name\": \"lobster\" } } } GET /products/_search { \"query\": { \"term\": { \"name\": \"Lobster\" } } } Full-text queries are analyzed \u00b6 GET /products/_search { \"query\": { \"match\": { \"name\": \"Lobster\" } } }","title":"Full text queries vs term level queries"},{"location":"Elastic_Stack/Introduction%20to%20Searching/full-text-queries-vs-term-level-queries/#full-text-queries-vs-term-level-queries","text":"","title":"Full text queries vs term level queries"},{"location":"Elastic_Stack/Introduction%20to%20Searching/full-text-queries-vs-term-level-queries/#term-level-queries-are-not-analyzed","text":"GET /products/_search { \"query\": { \"term\": { \"name\": \"lobster\" } } } GET /products/_search { \"query\": { \"term\": { \"name\": \"Lobster\" } } }","title":"Term level queries are not analyzed"},{"location":"Elastic_Stack/Introduction%20to%20Searching/full-text-queries-vs-term-level-queries/#full-text-queries-are-analyzed","text":"GET /products/_search { \"query\": { \"match\": { \"name\": \"Lobster\" } } }","title":"Full-text queries are analyzed"},{"location":"Elastic_Stack/Introduction%20to%20Searching/introducing-the-query-dsl/","text":"Introducing the Query DSL \u00b6 Matching all documents \u00b6 GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Introducing the Query DSL"},{"location":"Elastic_Stack/Introduction%20to%20Searching/introducing-the-query-dsl/#introducing-the-query-dsl","text":"","title":"Introducing the Query DSL"},{"location":"Elastic_Stack/Introduction%20to%20Searching/introducing-the-query-dsl/#matching-all-documents","text":"GET /products/_search { \"query\": { \"match_all\": {} } }","title":"Matching all documents"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/","text":"Searching with the request URI \u00b6 Matching all documents \u00b6 GET /products/_search?q=* Matching documents containing the term Lobster \u00b6 GET /products/_search?q=name:Lobster Matching documents containing the tag Meat \u00b6 GET /products/_search?q=tags:Meat Matching documents containing the tag Meat and name Tuna \u00b6 GET /products/_search?q=tags:Meat AND name:Tuna","title":"Searching with the request URI"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/#searching-with-the-request-uri","text":"","title":"Searching with the request URI"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/#matching-all-documents","text":"GET /products/_search?q=*","title":"Matching all documents"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/#matching-documents-containing-the-term-lobster","text":"GET /products/_search?q=name:Lobster","title":"Matching documents containing the term Lobster"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/#matching-documents-containing-the-tag-meat","text":"GET /products/_search?q=tags:Meat","title":"Matching documents containing the tag Meat"},{"location":"Elastic_Stack/Introduction%20to%20Searching/searching-with-the-request-uri/#matching-documents-containing-the-tag-meat-and-name-tuna","text":"GET /products/_search?q=tags:Meat AND name:Tuna","title":"Matching documents containing the tag Meat and name Tuna"},{"location":"Elastic_Stack/Introduction%20to%20Searching/understanding-relevance-scores/","text":"Understanding relevance scores \u00b6 GET /products/_search { \"explain\": true, \"query\": { \"term\": { \"name\": \"lobster\" } } }","title":"Understanding relevance scores"},{"location":"Elastic_Stack/Introduction%20to%20Searching/understanding-relevance-scores/#understanding-relevance-scores","text":"GET /products/_search { \"explain\": true, \"query\": { \"term\": { \"name\": \"lobster\" } } }","title":"Understanding relevance scores"},{"location":"Elastic_Stack/Joining%20Queries/adding-documents/","text":"Adding documents \u00b6 Adding departments \u00b6 PUT /department/_doc/1 { \"name\": \"Development\", \"join_field\": \"department\" } PUT /department/_doc/2 { \"name\": \"Marketing\", \"join_field\": \"department\" } Adding employees for departments \u00b6 PUT /department/_doc/3?routing=1 { \"name\": \"Bo Andersen\", \"age\": 28, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/4?routing=2 { \"name\": \"John Doe\", \"age\": 44, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } } PUT /department/_doc/5?routing=1 { \"name\": \"James Evans\", \"age\": 32, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/6?routing=1 { \"name\": \"Daniel Harris\", \"age\": 52, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/7?routing=2 { \"name\": \"Jane Park\", \"age\": 23, \"gender\": \"F\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } } PUT /department/_doc/8?routing=1 { \"name\": \"Christina Parker\", \"age\": 29, \"gender\": \"F\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } }","title":"Adding documents"},{"location":"Elastic_Stack/Joining%20Queries/adding-documents/#adding-documents","text":"","title":"Adding documents"},{"location":"Elastic_Stack/Joining%20Queries/adding-documents/#adding-departments","text":"PUT /department/_doc/1 { \"name\": \"Development\", \"join_field\": \"department\" } PUT /department/_doc/2 { \"name\": \"Marketing\", \"join_field\": \"department\" }","title":"Adding departments"},{"location":"Elastic_Stack/Joining%20Queries/adding-documents/#adding-employees-for-departments","text":"PUT /department/_doc/3?routing=1 { \"name\": \"Bo Andersen\", \"age\": 28, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/4?routing=2 { \"name\": \"John Doe\", \"age\": 44, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } } PUT /department/_doc/5?routing=1 { \"name\": \"James Evans\", \"age\": 32, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/6?routing=1 { \"name\": \"Daniel Harris\", \"age\": 52, \"gender\": \"M\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } } PUT /department/_doc/7?routing=2 { \"name\": \"Jane Park\", \"age\": 23, \"gender\": \"F\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } } PUT /department/_doc/8?routing=1 { \"name\": \"Christina Parker\", \"age\": 29, \"gender\": \"F\", \"join_field\": { \"name\": \"employee\", \"parent\": 1 } }","title":"Adding employees for departments"},{"location":"Elastic_Stack/Joining%20Queries/mapping-document-relationships/","text":"Mapping document relationships \u00b6 PUT /department/_mapping { \"properties\": { \"join_field\": { \"type\": \"join\", \"relations\": { \"department\": \"employee\" } } } }","title":"Mapping document relationships"},{"location":"Elastic_Stack/Joining%20Queries/mapping-document-relationships/#mapping-document-relationships","text":"PUT /department/_mapping { \"properties\": { \"join_field\": { \"type\": \"join\", \"relations\": { \"department\": \"employee\" } } } }","title":"Mapping document relationships"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/","text":"Multi-level relations \u00b6 Creating the index with mapping \u00b6 PUT /company { \"mappings\": { \"properties\": { \"join_field\": { \"type\": \"join\", \"relations\": { \"company\": [\"department\", \"supplier\"], \"department\": \"employee\" } } } } } Adding a company \u00b6 PUT /company/_doc/1 { \"name\": \"My Company Inc.\", \"join_field\": \"company\" } Adding a department \u00b6 PUT /company/_doc/2?routing=1 { \"name\": \"Development\", \"join_field\": { \"name\": \"department\", \"parent\": 1 } } Adding an employee \u00b6 PUT /company/_doc/3?routing=1 { \"name\": \"Bo Andersen\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } } Adding some more test data \u00b6 PUT /company/_doc/4 { \"name\": \"Another Company, Inc.\", \"join_field\": \"company\" } PUT /company/_doc/5?routing=4 { \"name\": \"Marketing\", \"join_field\": { \"name\": \"department\", \"parent\": 4 } } PUT /company/_doc/6?routing=4 { \"name\": \"John Doe\", \"join_field\": { \"name\": \"employee\", \"parent\": 5 } } Example of querying multi-level relations \u00b6 GET /company/_search { \"query\": { \"has_child\": { \"type\": \"department\", \"query\": { \"has_child\": { \"type\": \"employee\", \"query\": { \"term\": { \"name.keyword\": \"John Doe\" } } } } } } }","title":"Multi-level relations"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#multi-level-relations","text":"","title":"Multi-level relations"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#creating-the-index-with-mapping","text":"PUT /company { \"mappings\": { \"properties\": { \"join_field\": { \"type\": \"join\", \"relations\": { \"company\": [\"department\", \"supplier\"], \"department\": \"employee\" } } } } }","title":"Creating the index with mapping"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#adding-a-company","text":"PUT /company/_doc/1 { \"name\": \"My Company Inc.\", \"join_field\": \"company\" }","title":"Adding a company"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#adding-a-department","text":"PUT /company/_doc/2?routing=1 { \"name\": \"Development\", \"join_field\": { \"name\": \"department\", \"parent\": 1 } }","title":"Adding a department"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#adding-an-employee","text":"PUT /company/_doc/3?routing=1 { \"name\": \"Bo Andersen\", \"join_field\": { \"name\": \"employee\", \"parent\": 2 } }","title":"Adding an employee"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#adding-some-more-test-data","text":"PUT /company/_doc/4 { \"name\": \"Another Company, Inc.\", \"join_field\": \"company\" } PUT /company/_doc/5?routing=4 { \"name\": \"Marketing\", \"join_field\": { \"name\": \"department\", \"parent\": 4 } } PUT /company/_doc/6?routing=4 { \"name\": \"John Doe\", \"join_field\": { \"name\": \"employee\", \"parent\": 5 } }","title":"Adding some more test data"},{"location":"Elastic_Stack/Joining%20Queries/multi-level-relations/#example-of-querying-multi-level-relations","text":"GET /company/_search { \"query\": { \"has_child\": { \"type\": \"department\", \"query\": { \"has_child\": { \"type\": \"employee\", \"query\": { \"term\": { \"name.keyword\": \"John Doe\" } } } } } } }","title":"Example of querying multi-level relations"},{"location":"Elastic_Stack/Joining%20Queries/nested-inner-hits/","text":"Nested inner hits \u00b6 GET /department/_search { \"_source\": false, \"query\": { \"nested\": { \"path\": \"employees\", \"inner_hits\": {}, \"query\": { \"bool\": { \"must\": [ { \"match\": { \"employees.position\": \"intern\" } }, { \"term\": { \"employees.gender.keyword\": { \"value\": \"F\" } } } ] } } } } }","title":"Nested inner hits"},{"location":"Elastic_Stack/Joining%20Queries/nested-inner-hits/#nested-inner-hits","text":"GET /department/_search { \"_source\": false, \"query\": { \"nested\": { \"path\": \"employees\", \"inner_hits\": {}, \"query\": { \"bool\": { \"must\": [ { \"match\": { \"employees.position\": \"intern\" } }, { \"term\": { \"employees.gender.keyword\": { \"value\": \"F\" } } } ] } } } } }","title":"Nested inner hits"},{"location":"Elastic_Stack/Joining%20Queries/parent-child-inner-hits/","text":"Parent/child inner hits \u00b6 Including inner hits for the has_child query \u00b6 GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"inner_hits\": {}, \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } } Including inner hits for the has_parent query \u00b6 GET /department/_search { \"query\": { \"has_parent\": { \"inner_hits\": {}, \"parent_type\": \"department\", \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } }","title":"Parent/child inner hits"},{"location":"Elastic_Stack/Joining%20Queries/parent-child-inner-hits/#parentchild-inner-hits","text":"","title":"Parent/child inner hits"},{"location":"Elastic_Stack/Joining%20Queries/parent-child-inner-hits/#including-inner-hits-for-the-has_child-query","text":"GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"inner_hits\": {}, \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } }","title":"Including inner hits for the has_child query"},{"location":"Elastic_Stack/Joining%20Queries/parent-child-inner-hits/#including-inner-hits-for-the-has_parent-query","text":"GET /department/_search { \"query\": { \"has_parent\": { \"inner_hits\": {}, \"parent_type\": \"department\", \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } }","title":"Including inner hits for the has_parent query"},{"location":"Elastic_Stack/Joining%20Queries/querying-by-parent-id/","text":"Querying by parent \u00b6 GET /department/_search { \"query\": { \"parent_id\": { \"type\": \"employee\", \"id\": 1 } } }","title":"Querying by parent"},{"location":"Elastic_Stack/Joining%20Queries/querying-by-parent-id/#querying-by-parent","text":"GET /department/_search { \"query\": { \"parent_id\": { \"type\": \"employee\", \"id\": 1 } } }","title":"Querying by parent"},{"location":"Elastic_Stack/Joining%20Queries/querying-child-documents-by-parent/","text":"Querying child documents by parent \u00b6 Matching child documents by parent criteria \u00b6 GET /department/_search { \"query\": { \"has_parent\": { \"parent_type\": \"department\", \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } } Incorporating the parent documents' relevance scores \u00b6 GET /department/_search { \"query\": { \"has_parent\": { \"parent_type\": \"department\", \"score\": true, \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } }","title":"Querying child documents by parent"},{"location":"Elastic_Stack/Joining%20Queries/querying-child-documents-by-parent/#querying-child-documents-by-parent","text":"","title":"Querying child documents by parent"},{"location":"Elastic_Stack/Joining%20Queries/querying-child-documents-by-parent/#matching-child-documents-by-parent-criteria","text":"GET /department/_search { \"query\": { \"has_parent\": { \"parent_type\": \"department\", \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } }","title":"Matching child documents by parent criteria"},{"location":"Elastic_Stack/Joining%20Queries/querying-child-documents-by-parent/#incorporating-the-parent-documents-relevance-scores","text":"GET /department/_search { \"query\": { \"has_parent\": { \"parent_type\": \"department\", \"score\": true, \"query\": { \"term\": { \"name.keyword\": \"Development\" } } } } }","title":"Incorporating the parent documents' relevance scores"},{"location":"Elastic_Stack/Joining%20Queries/querying-nested-objects/","text":"Querying nested objects \u00b6 Creating the index with mapping \u00b6 PUT /department { \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\" }, \"employees\": { \"type\": \"nested\" } } } } Adding test documents \u00b6 PUT /department/_doc/1 { \"name\": \"Development\", \"employees\": [ { \"name\": \"Eric Green\", \"age\": 39, \"gender\": \"M\", \"position\": \"Big Data Specialist\" }, { \"name\": \"James Taylor\", \"age\": 27, \"gender\": \"M\", \"position\": \"Software Developer\" }, { \"name\": \"Gary Jenkins\", \"age\": 21, \"gender\": \"M\", \"position\": \"Intern\" }, { \"name\": \"Julie Powell\", \"age\": 26, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Benjamin Smith\", \"age\": 46, \"gender\": \"M\", \"position\": \"Senior Software Engineer\" } ] } PUT /department/_doc/2 { \"name\": \"HR & Marketing\", \"employees\": [ { \"name\": \"Patricia Lewis\", \"age\": 42, \"gender\": \"F\", \"position\": \"Senior Marketing Manager\" }, { \"name\": \"Maria Anderson\", \"age\": 56, \"gender\": \"F\", \"position\": \"Head of HR\" }, { \"name\": \"Margaret Harris\", \"age\": 19, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Ryan Nelson\", \"age\": 31, \"gender\": \"M\", \"position\": \"Marketing Manager\" }, { \"name\": \"Kathy Williams\", \"age\": 49, \"gender\": \"F\", \"position\": \"Senior Marketing Manager\" }, { \"name\": \"Jacqueline Hill\", \"age\": 28, \"gender\": \"F\", \"position\": \"Junior Marketing Manager\" }, { \"name\": \"Donald Morris\", \"age\": 39, \"gender\": \"M\", \"position\": \"SEO Specialist\" }, { \"name\": \"Evelyn Henderson\", \"age\": 24, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Earl Moore\", \"age\": 21, \"gender\": \"M\", \"position\": \"Junior SEO Specialist\" }, { \"name\": \"Phillip Sanchez\", \"age\": 35, \"gender\": \"M\", \"position\": \"SEM Specialist\" } ] } Querying nested fields \u00b6 GET /department/_search { \"query\": { \"nested\": { \"path\": \"employees\", \"query\": { \"bool\": { \"must\": [ { \"match\": { \"employees.position\": \"intern\" } }, { \"term\": { \"employees.gender.keyword\": { \"value\": \"F\" } } } ] } } } } }","title":"Querying nested objects"},{"location":"Elastic_Stack/Joining%20Queries/querying-nested-objects/#querying-nested-objects","text":"","title":"Querying nested objects"},{"location":"Elastic_Stack/Joining%20Queries/querying-nested-objects/#creating-the-index-with-mapping","text":"PUT /department { \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\" }, \"employees\": { \"type\": \"nested\" } } } }","title":"Creating the index with mapping"},{"location":"Elastic_Stack/Joining%20Queries/querying-nested-objects/#adding-test-documents","text":"PUT /department/_doc/1 { \"name\": \"Development\", \"employees\": [ { \"name\": \"Eric Green\", \"age\": 39, \"gender\": \"M\", \"position\": \"Big Data Specialist\" }, { \"name\": \"James Taylor\", \"age\": 27, \"gender\": \"M\", \"position\": \"Software Developer\" }, { \"name\": \"Gary Jenkins\", \"age\": 21, \"gender\": \"M\", \"position\": \"Intern\" }, { \"name\": \"Julie Powell\", \"age\": 26, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Benjamin Smith\", \"age\": 46, \"gender\": \"M\", \"position\": \"Senior Software Engineer\" } ] } PUT /department/_doc/2 { \"name\": \"HR & Marketing\", \"employees\": [ { \"name\": \"Patricia Lewis\", \"age\": 42, \"gender\": \"F\", \"position\": \"Senior Marketing Manager\" }, { \"name\": \"Maria Anderson\", \"age\": 56, \"gender\": \"F\", \"position\": \"Head of HR\" }, { \"name\": \"Margaret Harris\", \"age\": 19, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Ryan Nelson\", \"age\": 31, \"gender\": \"M\", \"position\": \"Marketing Manager\" }, { \"name\": \"Kathy Williams\", \"age\": 49, \"gender\": \"F\", \"position\": \"Senior Marketing Manager\" }, { \"name\": \"Jacqueline Hill\", \"age\": 28, \"gender\": \"F\", \"position\": \"Junior Marketing Manager\" }, { \"name\": \"Donald Morris\", \"age\": 39, \"gender\": \"M\", \"position\": \"SEO Specialist\" }, { \"name\": \"Evelyn Henderson\", \"age\": 24, \"gender\": \"F\", \"position\": \"Intern\" }, { \"name\": \"Earl Moore\", \"age\": 21, \"gender\": \"M\", \"position\": \"Junior SEO Specialist\" }, { \"name\": \"Phillip Sanchez\", \"age\": 35, \"gender\": \"M\", \"position\": \"SEM Specialist\" } ] }","title":"Adding test documents"},{"location":"Elastic_Stack/Joining%20Queries/querying-nested-objects/#querying-nested-fields","text":"GET /department/_search { \"query\": { \"nested\": { \"path\": \"employees\", \"query\": { \"bool\": { \"must\": [ { \"match\": { \"employees.position\": \"intern\" } }, { \"term\": { \"employees.gender.keyword\": { \"value\": \"F\" } } } ] } } } } }","title":"Querying nested fields"},{"location":"Elastic_Stack/Joining%20Queries/querying-parent-by-child-documents/","text":"Querying parent by child documents \u00b6 Finding parents with child documents matching a bool query \u00b6 GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } } Taking relevance scores into account with score_mode \u00b6 GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"score_mode\": \"sum\", \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } } Specifying the minimum and maximum number of children \u00b6 GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"score_mode\": \"sum\", \"min_children\": 2, \"max_children\": 5, \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } }","title":"Querying parent by child documents"},{"location":"Elastic_Stack/Joining%20Queries/querying-parent-by-child-documents/#querying-parent-by-child-documents","text":"","title":"Querying parent by child documents"},{"location":"Elastic_Stack/Joining%20Queries/querying-parent-by-child-documents/#finding-parents-with-child-documents-matching-a-bool-query","text":"GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } }","title":"Finding parents with child documents matching a bool query"},{"location":"Elastic_Stack/Joining%20Queries/querying-parent-by-child-documents/#taking-relevance-scores-into-account-with-score_mode","text":"GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"score_mode\": \"sum\", \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } }","title":"Taking relevance scores into account with score_mode"},{"location":"Elastic_Stack/Joining%20Queries/querying-parent-by-child-documents/#specifying-the-minimum-and-maximum-number-of-children","text":"GET /department/_search { \"query\": { \"has_child\": { \"type\": \"employee\", \"score_mode\": \"sum\", \"min_children\": 2, \"max_children\": 5, \"query\": { \"bool\": { \"must\": [ { \"range\": { \"age\": { \"gte\": 50 } } } ], \"should\": [ { \"term\": { \"gender.keyword\": \"M\" } } ] } } } } }","title":"Specifying the minimum and maximum number of children"},{"location":"Elastic_Stack/Joining%20Queries/terms-lookup-mechanism/","text":"Terms lookup mechanism \u00b6 Adding test data \u00b6 PUT /users/_doc/1 { \"name\": \"John Roberts\", \"following\" : [2, 3] } PUT /users/_doc/2 { \"name\": \"Elizabeth Ross\", \"following\" : [] } PUT /users/_doc/3 { \"name\": \"Jeremy Brooks\", \"following\" : [1, 2] } PUT /users/_doc/4 { \"name\": \"Diana Moore\", \"following\" : [3, 1] } PUT /stories/_doc/1 { \"user\": 3, \"content\": \"Wow look, a penguin!\" } PUT /stories/_doc/2 { \"user\": 1, \"content\": \"Just another day at the office... #coffee\" } PUT /stories/_doc/3 { \"user\": 1, \"content\": \"Making search great again! #elasticsearch #elk\" } PUT /stories/_doc/4 { \"user\": 4, \"content\": \"Had a blast today! #rollercoaster #amusementpark\" } PUT /stories/_doc/5 { \"user\": 4, \"content\": \"Yay, I just got hired as an Elasticsearch consultant - so excited!\" } PUT /stories/_doc/6 { \"user\": 2, \"content\": \"Chilling at the beach @ Greece #vacation #goodtimes\" } Querying stories from a user's followers \u00b6 GET /stories/_search { \"query\": { \"terms\": { \"user\": { \"index\": \"users\", \"id\": \"1\", \"path\": \"following\" } } } }","title":"Terms lookup mechanism"},{"location":"Elastic_Stack/Joining%20Queries/terms-lookup-mechanism/#terms-lookup-mechanism","text":"","title":"Terms lookup mechanism"},{"location":"Elastic_Stack/Joining%20Queries/terms-lookup-mechanism/#adding-test-data","text":"PUT /users/_doc/1 { \"name\": \"John Roberts\", \"following\" : [2, 3] } PUT /users/_doc/2 { \"name\": \"Elizabeth Ross\", \"following\" : [] } PUT /users/_doc/3 { \"name\": \"Jeremy Brooks\", \"following\" : [1, 2] } PUT /users/_doc/4 { \"name\": \"Diana Moore\", \"following\" : [3, 1] } PUT /stories/_doc/1 { \"user\": 3, \"content\": \"Wow look, a penguin!\" } PUT /stories/_doc/2 { \"user\": 1, \"content\": \"Just another day at the office... #coffee\" } PUT /stories/_doc/3 { \"user\": 1, \"content\": \"Making search great again! #elasticsearch #elk\" } PUT /stories/_doc/4 { \"user\": 4, \"content\": \"Had a blast today! #rollercoaster #amusementpark\" } PUT /stories/_doc/5 { \"user\": 4, \"content\": \"Yay, I just got hired as an Elasticsearch consultant - so excited!\" } PUT /stories/_doc/6 { \"user\": 2, \"content\": \"Chilling at the beach @ Greece #vacation #goodtimes\" }","title":"Adding test data"},{"location":"Elastic_Stack/Joining%20Queries/terms-lookup-mechanism/#querying-stories-from-a-users-followers","text":"GET /stories/_search { \"query\": { \"terms\": { \"user\": { \"index\": \"users\", \"id\": \"1\", \"path\": \"following\" } } } }","title":"Querying stories from a user's followers"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/","text":"Adding analyzers to existing indices \u00b6 Close analyzer_test index \u00b6 POST /analyzer_test/_close Add new analyzer \u00b6 PUT /analyzer_test/_settings { \"analysis\": { \"analyzer\": { \"my_second_analyzer\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"char_filter\": [\"html_strip\"], \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ] } } } } Open analyzer_test index \u00b6 POST /analyzer_test/_open Retrieve index settings \u00b6 GET /analyzer_test/_settings","title":"Adding analyzers to existing indices"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/#adding-analyzers-to-existing-indices","text":"","title":"Adding analyzers to existing indices"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/#close-analyzer_test-index","text":"POST /analyzer_test/_close","title":"Close analyzer_test index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/#add-new-analyzer","text":"PUT /analyzer_test/_settings { \"analysis\": { \"analyzer\": { \"my_second_analyzer\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"char_filter\": [\"html_strip\"], \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ] } } } }","title":"Add new analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/#open-analyzer_test-index","text":"POST /analyzer_test/_open","title":"Open analyzer_test index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-analyzers-to-existing-indices/#retrieve-index-settings","text":"GET /analyzer_test/_settings","title":"Retrieve index settings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-explicit-mappings/","text":"Adding explicit mappings \u00b6 Add field mappings for reviews index \u00b6 PUT /reviews { \"mappings\": { \"properties\": { \"rating\": { \"type\": \"float\" }, \"content\": { \"type\": \"text\" }, \"product_id\": { \"type\": \"integer\" }, \"author\": { \"properties\": { \"first_name\": { \"type\": \"text\" }, \"last_name\": { \"type\": \"text\" }, \"email\": { \"type\": \"keyword\" } } } } } } Index a test document \u00b6 PUT /reviews/_doc/1 { \"rating\": 5.0, \"content\": \"Outstanding course! Bo really taught me a lot about Elasticsearch!\", \"product_id\": 123, \"author\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"email\": \"johndoe123@example.com\" } }","title":"Adding explicit mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-explicit-mappings/#adding-explicit-mappings","text":"","title":"Adding explicit mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-explicit-mappings/#add-field-mappings-for-reviews-index","text":"PUT /reviews { \"mappings\": { \"properties\": { \"rating\": { \"type\": \"float\" }, \"content\": { \"type\": \"text\" }, \"product_id\": { \"type\": \"integer\" }, \"author\": { \"properties\": { \"first_name\": { \"type\": \"text\" }, \"last_name\": { \"type\": \"text\" }, \"email\": { \"type\": \"keyword\" } } } } } }","title":"Add field mappings for reviews index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-explicit-mappings/#index-a-test-document","text":"PUT /reviews/_doc/1 { \"rating\": 5.0, \"content\": \"Outstanding course! Bo really taught me a lot about Elasticsearch!\", \"product_id\": 123, \"author\": { \"first_name\": \"John\", \"last_name\": \"Doe\", \"email\": \"johndoe123@example.com\" } }","title":"Index a test document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-mappings-to-existing-indices/","text":"Adding mappings to existing indices \u00b6 Add new field mapping to existing index \u00b6 PUT /reviews/_mapping { \"properties\": { \"created_at\": { \"type\": \"date\" } } } Retrieve the mapping \u00b6 GET /reviews/_mapping","title":"Adding mappings to existing indices"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-mappings-to-existing-indices/#adding-mappings-to-existing-indices","text":"","title":"Adding mappings to existing indices"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-mappings-to-existing-indices/#add-new-field-mapping-to-existing-index","text":"PUT /reviews/_mapping { \"properties\": { \"created_at\": { \"type\": \"date\" } } }","title":"Add new field mapping to existing index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/adding-mappings-to-existing-indices/#retrieve-the-mapping","text":"GET /reviews/_mapping","title":"Retrieve the mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/","text":"Combining explicit and dynamic mapping \u00b6 Create index with one field mapping \u00b6 PUT /people { \"mappings\": { \"properties\": { \"first_name\": { \"type\": \"text\" } } } } Index a test document with an unmapped field \u00b6 POST /people/_doc { \"first_name\": \"Bo\", \"last_name\": \"Andersen\" } Retrieve mapping \u00b6 GET /people/_mapping Clean up \u00b6 DELETE /people","title":"Combining explicit and dynamic mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/#combining-explicit-and-dynamic-mapping","text":"","title":"Combining explicit and dynamic mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/#create-index-with-one-field-mapping","text":"PUT /people { \"mappings\": { \"properties\": { \"first_name\": { \"type\": \"text\" } } } }","title":"Create index with one field mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/#index-a-test-document-with-an-unmapped-field","text":"POST /people/_doc { \"first_name\": \"Bo\", \"last_name\": \"Andersen\" }","title":"Index a test document with an unmapped field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/#retrieve-mapping","text":"GET /people/_mapping","title":"Retrieve mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/combining-explicit-and-dynamic-mapping/#clean-up","text":"DELETE /people","title":"Clean up"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/","text":"Configuring dynamic mapping \u00b6 Disable dynamic mapping \u00b6 PUT /people { \"mappings\": { \"dynamic\": false, \"properties\": { \"first_name\": { \"type\": \"text\" } } } } Set dynamic mapping to strict \u00b6 PUT /people { \"mappings\": { \"dynamic\": \"strict\", \"properties\": { \"first_name\": { \"type\": \"text\" } } } } Index a test document \u00b6 POST /people/_doc { \"first_name\": \"Bo\", \"last_name\": \"Andersen\" } Retrieve mapping \u00b6 GET /people/_mapping Search first_name field \u00b6 GET /people/_search { \"query\": { \"match\": { \"first_name\": \"Bo\" } } } Search last_name field \u00b6 GET /people/_search { \"query\": { \"match\": { \"last_name\": \"Andersen\" } } } Inheritance for the dynamic parameter \u00b6 The following example sets the dynamic parameter to \"strict\" at the root level, but overrides it with a value of true for the specifications.other field mapping. Mapping \u00b6 PUT /computers { \"mappings\": { \"dynamic\": \"strict\", \"properties\": { \"name\": { \"type\": \"text\" }, \"specifications\": { \"properties\": { \"cpu\": { \"properties\": { \"name\": { \"type\": \"text\" } } }, \"other\": { \"dynamic\": true, \"properties\": { ... } } } } } } } Example document (invalid) \u00b6 POST /computers/_doc { \"name\": \"Gamer PC\", \"specifications\": { \"cpu\": { \"name\": \"Intel Core i7-9700K\", \"frequency\": 3.6 } } } Example document (OK) \u00b6 POST /computers/_doc { \"name\": \"Gamer PC\", \"specifications\": { \"cpu\": { \"name\": \"Intel Core i7-9700K\" }, \"other\": { \"security\": \"Kensington\" } } } Enabling numeric detection \u00b6 When enabling numeric detection, Elasticsearch will check the contents of strings to see if they contain only numeric values - and map the fields accordingly as either float or long . Mapping \u00b6 PUT /computers { \"mappings\": { \"numeric_detection\": true } } Example document \u00b6 POST /computers/_doc { \"specifications\": { \"other\": { \"max_ram_gb\": \"32\", # long \"bluetooth\": \"5.2\" # float } } } Date detection \u00b6 Disabling date detection \u00b6 PUT /computers { \"mappings\": { \"date_detection\": false } } Configuring dynamic date formats \u00b6 PUT /computers { \"mappings\": { \"dynamic_date_formats\": [\"dd-MM-yyyy\"] } } Clean up \u00b6 DELETE /people","title":"Configuring dynamic mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#configuring-dynamic-mapping","text":"","title":"Configuring dynamic mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#disable-dynamic-mapping","text":"PUT /people { \"mappings\": { \"dynamic\": false, \"properties\": { \"first_name\": { \"type\": \"text\" } } } }","title":"Disable dynamic mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#set-dynamic-mapping-to-strict","text":"PUT /people { \"mappings\": { \"dynamic\": \"strict\", \"properties\": { \"first_name\": { \"type\": \"text\" } } } }","title":"Set dynamic mapping to strict"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#index-a-test-document","text":"POST /people/_doc { \"first_name\": \"Bo\", \"last_name\": \"Andersen\" }","title":"Index a test document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#retrieve-mapping","text":"GET /people/_mapping","title":"Retrieve mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#search-first_name-field","text":"GET /people/_search { \"query\": { \"match\": { \"first_name\": \"Bo\" } } }","title":"Search first_name field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#search-last_name-field","text":"GET /people/_search { \"query\": { \"match\": { \"last_name\": \"Andersen\" } } }","title":"Search last_name field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#inheritance-for-the-dynamic-parameter","text":"The following example sets the dynamic parameter to \"strict\" at the root level, but overrides it with a value of true for the specifications.other field mapping.","title":"Inheritance for the dynamic parameter"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#mapping","text":"PUT /computers { \"mappings\": { \"dynamic\": \"strict\", \"properties\": { \"name\": { \"type\": \"text\" }, \"specifications\": { \"properties\": { \"cpu\": { \"properties\": { \"name\": { \"type\": \"text\" } } }, \"other\": { \"dynamic\": true, \"properties\": { ... } } } } } } }","title":"Mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#example-document-invalid","text":"POST /computers/_doc { \"name\": \"Gamer PC\", \"specifications\": { \"cpu\": { \"name\": \"Intel Core i7-9700K\", \"frequency\": 3.6 } } }","title":"Example document (invalid)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#example-document-ok","text":"POST /computers/_doc { \"name\": \"Gamer PC\", \"specifications\": { \"cpu\": { \"name\": \"Intel Core i7-9700K\" }, \"other\": { \"security\": \"Kensington\" } } }","title":"Example document (OK)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#enabling-numeric-detection","text":"When enabling numeric detection, Elasticsearch will check the contents of strings to see if they contain only numeric values - and map the fields accordingly as either float or long .","title":"Enabling numeric detection"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#mapping_1","text":"PUT /computers { \"mappings\": { \"numeric_detection\": true } }","title":"Mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#example-document","text":"POST /computers/_doc { \"specifications\": { \"other\": { \"max_ram_gb\": \"32\", # long \"bluetooth\": \"5.2\" # float } } }","title":"Example document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#date-detection","text":"","title":"Date detection"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#disabling-date-detection","text":"PUT /computers { \"mappings\": { \"date_detection\": false } }","title":"Disabling date detection"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#configuring-dynamic-date-formats","text":"PUT /computers { \"mappings\": { \"dynamic_date_formats\": [\"dd-MM-yyyy\"] } }","title":"Configuring dynamic date formats"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/configuring-dynamic-mapping/#clean-up","text":"DELETE /people","title":"Clean up"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/","text":"Creating custom analyzers \u00b6 Remove HTML tags and convert HTML entities \u00b6 POST /_analyze { \"char_filter\": [\"html_strip\"], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" } Add the standard tokenizer \u00b6 POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" } Add the lowercase token filter \u00b6 POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" } Add the stop token filter \u00b6 This removes English stop words by default. POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" } Add the asciifolding token filter \u00b6 Convert characters to their ASCII equivalent. POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" } Create a custom analyzer named my_custom_analyzer \u00b6 PUT /analyzer_test { \"settings\": { \"analysis\": { \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ] } } } } } Configure the analyzer to remove Danish stop words \u00b6 To run this query, change the index name to avoid a conflict. Remember to remove the comments. :wink: PUT /analyzer_test { \"settings\": { \"analysis\": { \"filter\": { \"danish_stop\": { \"type\": \"stop\", \"stopwords\": \"_danish_\" } }, \"char_filter\": { # Add character filters here }, \"tokenizer\": { # Add tokenizers here }, \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"danish_stop\", \"asciifolding\" ] } } } } } Test the custom analyzer \u00b6 POST /analyzer_test/_analyze { \"analyzer\": \"my_custom_analyzer\", \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Creating custom analyzers"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#creating-custom-analyzers","text":"","title":"Creating custom analyzers"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#remove-html-tags-and-convert-html-entities","text":"POST /_analyze { \"char_filter\": [\"html_strip\"], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Remove HTML tags and convert HTML entities"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#add-the-standard-tokenizer","text":"POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Add the standard tokenizer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#add-the-lowercase-token-filter","text":"POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Add the lowercase token filter"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#add-the-stop-token-filter","text":"This removes English stop words by default. POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Add the stop token filter"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#add-the-asciifolding-token-filter","text":"Convert characters to their ASCII equivalent. POST /_analyze { \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ], \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Add the asciifolding token filter"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#create-a-custom-analyzer-named-my_custom_analyzer","text":"PUT /analyzer_test { \"settings\": { \"analysis\": { \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"stop\", \"asciifolding\" ] } } } } }","title":"Create a custom analyzer named my_custom_analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#configure-the-analyzer-to-remove-danish-stop-words","text":"To run this query, change the index name to avoid a conflict. Remember to remove the comments. :wink: PUT /analyzer_test { \"settings\": { \"analysis\": { \"filter\": { \"danish_stop\": { \"type\": \"stop\", \"stopwords\": \"_danish_\" } }, \"char_filter\": { # Add character filters here }, \"tokenizer\": { # Add tokenizers here }, \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"char_filter\": [\"html_strip\"], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"danish_stop\", \"asciifolding\" ] } } } } }","title":"Configure the analyzer to remove Danish stop words"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/creating-custom-analyzers/#test-the-custom-analyzer","text":"POST /analyzer_test/_analyze { \"analyzer\": \"my_custom_analyzer\", \"text\": \"I&apos;m in a <em>good</em> mood&nbsp;-&nbsp;and I <strong>love</strong> a\u00e7a\u00ed!\" }","title":"Test the custom analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/defining-field-aliases/","text":"Defining field aliases \u00b6 Add comment alias pointing to the content field \u00b6 PUT /reviews/_mapping { \"properties\": { \"comment\": { \"type\": \"alias\", \"path\": \"content\" } } } Using the field alias \u00b6 GET /reviews/_search { \"query\": { \"match\": { \"comment\": \"outstanding\" } } } Using the \"original\" field name still works \u00b6 GET /reviews/_search { \"query\": { \"match\": { \"content\": \"outstanding\" } } }","title":"Defining field aliases"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/defining-field-aliases/#defining-field-aliases","text":"","title":"Defining field aliases"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/defining-field-aliases/#add-comment-alias-pointing-to-the-content-field","text":"PUT /reviews/_mapping { \"properties\": { \"comment\": { \"type\": \"alias\", \"path\": \"content\" } } }","title":"Add comment alias pointing to the content field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/defining-field-aliases/#using-the-field-alias","text":"GET /reviews/_search { \"query\": { \"match\": { \"comment\": \"outstanding\" } } }","title":"Using the field alias"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/defining-field-aliases/#using-the-original-field-name-still-works","text":"GET /reviews/_search { \"query\": { \"match\": { \"content\": \"outstanding\" } } }","title":"Using the \"original\" field name still works"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/","text":"Dynamic templates \u00b6 Map whole numbers to integer instead of long \u00b6 PUT /dynamic_template_test { \"mappings\": { \"dynamic_templates\": [ { \"integers\": { \"match_mapping_type\": \"long\", \"mapping\": { \"type\": \"integer\" } } } ] } } Test the dynamic template \u00b6 POST /dynamic_template_test/_doc { \"in_stock\": 123 } Retrieve mapping (and dynamic template) \u00b6 GET /dynamic_template_test/_mapping Modify default mapping for strings (set ignore_above to 512) \u00b6 PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"strings\": { \"match_mapping_type\": \"string\", \"mapping\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 512 } } } } } ] } } Using match and unmatch \u00b6 PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"strings_only_text\": { \"match_mapping_type\": \"string\", \"match\": \"text_*\", \"unmatch\": \"*_keyword\", \"mapping\": { \"type\": \"text\" } } }, { \"strings_only_keyword\": { \"match_mapping_type\": \"string\", \"match\": \"*_keyword\", \"mapping\": { \"type\": \"keyword\" } } } ] } } POST /test_index/_doc { \"text_product_description\": \"A description.\", \"text_product_id_keyword\": \"ABC-123\" } Setting match_pattern to regex \u00b6 PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"names\": { \"match_mapping_type\": \"string\", \"match\": \"^[a-zA-Z]+_name$\", \"match_pattern\": \"regex\", \"mapping\": { \"type\": \"text\" } } } ] } } POST /test_index/_doc { \"first_name\": \"John\", \"middle_name\": \"Edward\", \"last_name\": \"Doe\" } Using path_match \u00b6 PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"copy_to_full_name\": { \"match_mapping_type\": \"string\", \"path_match\": \"employer.name.*\", \"mapping\": { \"type\": \"text\", \"copy_to\": \"full_name\" } } } ] } } POST /test_index/_doc { \"employer\": { \"name\": { \"first_name\": \"John\", \"middle_name\": \"Edward\", \"last_name\": \"Doe\" } } } Using placeholders \u00b6 PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"no_doc_values\": { \"match_mapping_type\": \"*\", \"mapping\": { \"type\": \"{dynamic_type}\", \"index\": false } } } ] } } POST /test_index/_doc { \"name\": \"John Doe\", \"age\": 26 }","title":"Dynamic templates"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#dynamic-templates","text":"","title":"Dynamic templates"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#map-whole-numbers-to-integer-instead-of-long","text":"PUT /dynamic_template_test { \"mappings\": { \"dynamic_templates\": [ { \"integers\": { \"match_mapping_type\": \"long\", \"mapping\": { \"type\": \"integer\" } } } ] } }","title":"Map whole numbers to integer instead of long"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#test-the-dynamic-template","text":"POST /dynamic_template_test/_doc { \"in_stock\": 123 }","title":"Test the dynamic template"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#retrieve-mapping-and-dynamic-template","text":"GET /dynamic_template_test/_mapping","title":"Retrieve mapping (and dynamic template)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#modify-default-mapping-for-strings-set-ignore_above-to-512","text":"PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"strings\": { \"match_mapping_type\": \"string\", \"mapping\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 512 } } } } } ] } }","title":"Modify default mapping for strings (set ignore_above to 512)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#using-match-and-unmatch","text":"PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"strings_only_text\": { \"match_mapping_type\": \"string\", \"match\": \"text_*\", \"unmatch\": \"*_keyword\", \"mapping\": { \"type\": \"text\" } } }, { \"strings_only_keyword\": { \"match_mapping_type\": \"string\", \"match\": \"*_keyword\", \"mapping\": { \"type\": \"keyword\" } } } ] } } POST /test_index/_doc { \"text_product_description\": \"A description.\", \"text_product_id_keyword\": \"ABC-123\" }","title":"Using match and unmatch"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#setting-match_pattern-to-regex","text":"PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"names\": { \"match_mapping_type\": \"string\", \"match\": \"^[a-zA-Z]+_name$\", \"match_pattern\": \"regex\", \"mapping\": { \"type\": \"text\" } } } ] } } POST /test_index/_doc { \"first_name\": \"John\", \"middle_name\": \"Edward\", \"last_name\": \"Doe\" }","title":"Setting match_pattern to regex"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#using-path_match","text":"PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"copy_to_full_name\": { \"match_mapping_type\": \"string\", \"path_match\": \"employer.name.*\", \"mapping\": { \"type\": \"text\", \"copy_to\": \"full_name\" } } } ] } } POST /test_index/_doc { \"employer\": { \"name\": { \"first_name\": \"John\", \"middle_name\": \"Edward\", \"last_name\": \"Doe\" } } }","title":"Using path_match"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/dynamic-templates/#using-placeholders","text":"PUT /test_index { \"mappings\": { \"dynamic_templates\": [ { \"no_doc_values\": { \"match_mapping_type\": \"*\", \"mapping\": { \"type\": \"{dynamic_type}\", \"index\": false } } } ] } } POST /test_index/_doc { \"name\": \"John Doe\", \"age\": 26 }","title":"Using placeholders"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/","text":"How dates work in Elasticsearch \u00b6 Supplying only a date \u00b6 PUT /reviews/_doc/2 { \"rating\": 4.5, \"content\": \"Not bad. Not bad at all!\", \"product_id\": 123, \"created_at\": \"2015-03-27\", \"author\": { \"first_name\": \"Average\", \"last_name\": \"Joe\", \"email\": \"avgjoe@example.com\" } } Supplying both a date and time \u00b6 PUT /reviews/_doc/3 { \"rating\": 3.5, \"content\": \"Could be better\", \"product_id\": 123, \"created_at\": \"2015-04-15T13:07:41Z\", \"author\": { \"first_name\": \"Spencer\", \"last_name\": \"Pearson\", \"email\": \"spearson@example.com\" } } Specifying the UTC offset \u00b6 PUT /reviews/_doc/4 { \"rating\": 5.0, \"content\": \"Incredible!\", \"product_id\": 123, \"created_at\": \"2015-01-28T09:21:51+01:00\", \"author\": { \"first_name\": \"Adam\", \"last_name\": \"Jones\", \"email\": \"adam.jones@example.com\" } } Supplying a timestamp (milliseconds since the epoch) \u00b6 # Equivalent to 2015-07-04T12:01:24Z PUT /reviews/_doc/5 { \"rating\": 4.5, \"content\": \"Very useful\", \"product_id\": 123, \"created_at\": 1436011284000, \"author\": { \"first_name\": \"Taylor\", \"last_name\": \"West\", \"email\": \"twest@example.com\" } } Retrieving documents \u00b6 GET /reviews/_search { \"query\": { \"match_all\": {} } }","title":"How dates work in Elasticsearch"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#how-dates-work-in-elasticsearch","text":"","title":"How dates work in Elasticsearch"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#supplying-only-a-date","text":"PUT /reviews/_doc/2 { \"rating\": 4.5, \"content\": \"Not bad. Not bad at all!\", \"product_id\": 123, \"created_at\": \"2015-03-27\", \"author\": { \"first_name\": \"Average\", \"last_name\": \"Joe\", \"email\": \"avgjoe@example.com\" } }","title":"Supplying only a date"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#supplying-both-a-date-and-time","text":"PUT /reviews/_doc/3 { \"rating\": 3.5, \"content\": \"Could be better\", \"product_id\": 123, \"created_at\": \"2015-04-15T13:07:41Z\", \"author\": { \"first_name\": \"Spencer\", \"last_name\": \"Pearson\", \"email\": \"spearson@example.com\" } }","title":"Supplying both a date and time"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#specifying-the-utc-offset","text":"PUT /reviews/_doc/4 { \"rating\": 5.0, \"content\": \"Incredible!\", \"product_id\": 123, \"created_at\": \"2015-01-28T09:21:51+01:00\", \"author\": { \"first_name\": \"Adam\", \"last_name\": \"Jones\", \"email\": \"adam.jones@example.com\" } }","title":"Specifying the UTC offset"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#supplying-a-timestamp-milliseconds-since-the-epoch","text":"# Equivalent to 2015-07-04T12:01:24Z PUT /reviews/_doc/5 { \"rating\": 4.5, \"content\": \"Very useful\", \"product_id\": 123, \"created_at\": 1436011284000, \"author\": { \"first_name\": \"Taylor\", \"last_name\": \"West\", \"email\": \"twest@example.com\" } }","title":"Supplying a timestamp (milliseconds since the epoch)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-dates-work-in-elasticsearch/#retrieving-documents","text":"GET /reviews/_search { \"query\": { \"match_all\": {} } }","title":"Retrieving documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-the-keyword-data-type-works/","text":"How the keyword data type works \u00b6 Testing the keyword analyzer \u00b6 POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"analyzer\": \"keyword\" }","title":"How the `keyword` data type works"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-the-keyword-data-type-works/#how-the-keyword-data-type-works","text":"","title":"How the keyword data type works"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/how-the-keyword-data-type-works/#testing-the-keyword-analyzer","text":"POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"analyzer\": \"keyword\" }","title":"Testing the keyword analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/index-templates/","text":"Index templates \u00b6 Adding an index template named access-logs \u00b6 PUT /_template/access-logs { \"index_patterns\": [\"access-logs-*\"], \"settings\": { \"number_of_shards\": 2, \"index.mapping.coerce\": false }, \"mappings\": { \"properties\": { \"@timestamp\": { \"type\": \"date\" }, \"url.original\": { \"type\": \"keyword\" }, \"http.request.referrer\": { \"type\": \"keyword\" }, \"http.response.status_code\": { \"type\": \"long\" } } } } Adding an index matching the index template's pattern \u00b6 PUT /access-logs-2020-01-01 Verify that the mapping is applied \u00b6 GET /access-logs-2020-01-01","title":"Index templates"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/index-templates/#index-templates","text":"","title":"Index templates"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/index-templates/#adding-an-index-template-named-access-logs","text":"PUT /_template/access-logs { \"index_patterns\": [\"access-logs-*\"], \"settings\": { \"number_of_shards\": 2, \"index.mapping.coerce\": false }, \"mappings\": { \"properties\": { \"@timestamp\": { \"type\": \"date\" }, \"url.original\": { \"type\": \"keyword\" }, \"http.request.referrer\": { \"type\": \"keyword\" }, \"http.response.status_code\": { \"type\": \"long\" } } } }","title":"Adding an index template named access-logs"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/index-templates/#adding-an-index-matching-the-index-templates-pattern","text":"PUT /access-logs-2020-01-01","title":"Adding an index matching the index template's pattern"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/index-templates/#verify-that-the-mapping-is-applied","text":"GET /access-logs-2020-01-01","title":"Verify that the mapping is applied"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/","text":"Multi-field mappings \u00b6 Add keyword mapping to a text field \u00b6 PUT /multi_field_test { \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\" }, \"ingredients\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } } } } } Index a test document \u00b6 POST /multi_field_test/_doc { \"description\": \"To make this spaghetti carbonara, you first need to...\", \"ingredients\": [\"Spaghetti\", \"Bacon\", \"Eggs\"] } Retrieve documents \u00b6 GET /multi_field_test/_search { \"query\": { \"match_all\": {} } } Querying the text mapping \u00b6 GET /multi_field_test/_search { \"query\": { \"match\": { \"ingredients\": \"Spaghetti\" } } } Querying the keyword mapping \u00b6 GET /multi_field_test/_search { \"query\": { \"term\": { \"ingredients.keyword\": \"Spaghetti\" } } } Clean up \u00b6 DELETE /multi_field_test","title":"Multi-field mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#multi-field-mappings","text":"","title":"Multi-field mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#add-keyword-mapping-to-a-text-field","text":"PUT /multi_field_test { \"mappings\": { \"properties\": { \"description\": { \"type\": \"text\" }, \"ingredients\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } } } } }","title":"Add keyword mapping to a text field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#index-a-test-document","text":"POST /multi_field_test/_doc { \"description\": \"To make this spaghetti carbonara, you first need to...\", \"ingredients\": [\"Spaghetti\", \"Bacon\", \"Eggs\"] }","title":"Index a test document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#retrieve-documents","text":"GET /multi_field_test/_search { \"query\": { \"match_all\": {} } }","title":"Retrieve documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#querying-the-text-mapping","text":"GET /multi_field_test/_search { \"query\": { \"match\": { \"ingredients\": \"Spaghetti\" } } }","title":"Querying the text mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#querying-the-keyword-mapping","text":"GET /multi_field_test/_search { \"query\": { \"term\": { \"ingredients.keyword\": \"Spaghetti\" } } }","title":"Querying the keyword mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/multi-field-mappings/#clean-up","text":"DELETE /multi_field_test","title":"Clean up"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/","text":"Reindexing documents with the Reindex API \u00b6 Add new index with new mapping \u00b6 PUT /reviews_new { \"mappings\" : { \"properties\" : { \"author\" : { \"properties\" : { \"email\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 }, \"first_name\" : { \"type\" : \"text\" }, \"last_name\" : { \"type\" : \"text\" } } }, \"content\" : { \"type\" : \"text\" }, \"created_at\" : { \"type\" : \"date\" }, \"product_id\" : { \"type\" : \"keyword\" }, \"rating\" : { \"type\" : \"float\" } } } } Retrieve mapping \u00b6 GET /reviews/_mappings Reindex documents into reviews_new \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" } } Delete all documents \u00b6 POST /reviews_new/_delete_by_query { \"query\": { \"match_all\": {} } } Convert product_id values to strings \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" if (ctx._source.product_id != null) { ctx._source.product_id = ctx._source.product_id.toString(); } \"\"\" } } Retrieve documents \u00b6 GET /reviews_new/_search { \"query\": { \"match_all\": {} } } Reindex specific documents \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\", \"query\": { \"match_all\": { } } }, \"dest\": { \"index\": \"reviews_new\" } } Reindex only positive reviews \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\", \"query\": { \"range\": { \"rating\": { \"gte\": 4.0 } } } }, \"dest\": { \"index\": \"reviews_new\" } } Removing fields (source filtering) \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\", \"_source\": [\"content\", \"created_at\", \"rating\"] }, \"dest\": { \"index\": \"reviews_new\" } } Changing a field's name \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" # Rename \"content\" field to \"comment\" ctx._source.comment = ctx._source.remove(\"content\"); \"\"\" } } Ignore reviews with ratings below 4.0 \u00b6 POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" if (ctx._source.rating < 4.0) { ctx.op = \"noop\"; # Can also be set to \"delete\" } \"\"\" } }","title":"Reindexing documents with the Reindex API"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#reindexing-documents-with-the-reindex-api","text":"","title":"Reindexing documents with the Reindex API"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#add-new-index-with-new-mapping","text":"PUT /reviews_new { \"mappings\" : { \"properties\" : { \"author\" : { \"properties\" : { \"email\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 }, \"first_name\" : { \"type\" : \"text\" }, \"last_name\" : { \"type\" : \"text\" } } }, \"content\" : { \"type\" : \"text\" }, \"created_at\" : { \"type\" : \"date\" }, \"product_id\" : { \"type\" : \"keyword\" }, \"rating\" : { \"type\" : \"float\" } } } }","title":"Add new index with new mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#retrieve-mapping","text":"GET /reviews/_mappings","title":"Retrieve mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#reindex-documents-into-reviews_new","text":"POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" } }","title":"Reindex documents into reviews_new"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#delete-all-documents","text":"POST /reviews_new/_delete_by_query { \"query\": { \"match_all\": {} } }","title":"Delete all documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#convert-product_id-values-to-strings","text":"POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" if (ctx._source.product_id != null) { ctx._source.product_id = ctx._source.product_id.toString(); } \"\"\" } }","title":"Convert product_id values to strings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#retrieve-documents","text":"GET /reviews_new/_search { \"query\": { \"match_all\": {} } }","title":"Retrieve documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#reindex-specific-documents","text":"POST /_reindex { \"source\": { \"index\": \"reviews\", \"query\": { \"match_all\": { } } }, \"dest\": { \"index\": \"reviews_new\" } }","title":"Reindex specific documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#reindex-only-positive-reviews","text":"POST /_reindex { \"source\": { \"index\": \"reviews\", \"query\": { \"range\": { \"rating\": { \"gte\": 4.0 } } } }, \"dest\": { \"index\": \"reviews_new\" } }","title":"Reindex only positive reviews"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#removing-fields-source-filtering","text":"POST /_reindex { \"source\": { \"index\": \"reviews\", \"_source\": [\"content\", \"created_at\", \"rating\"] }, \"dest\": { \"index\": \"reviews_new\" } }","title":"Removing fields (source filtering)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#changing-a-fields-name","text":"POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" # Rename \"content\" field to \"comment\" ctx._source.comment = ctx._source.remove(\"content\"); \"\"\" } }","title":"Changing a field's name"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/reindexing-documents-with-the-reindex-api/#ignore-reviews-with-ratings-below-40","text":"POST /_reindex { \"source\": { \"index\": \"reviews\" }, \"dest\": { \"index\": \"reviews_new\" }, \"script\": { \"source\": \"\"\" if (ctx._source.rating < 4.0) { ctx.op = \"noop\"; # Can also be set to \"delete\" } \"\"\" } }","title":"Ignore reviews with ratings below 4.0"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/retrieving-mappings/","text":"Retrieving mappings \u00b6 Retrieving mappings for the reviews index \u00b6 GET /reviews/_mapping Retrieving mapping for the content field \u00b6 GET /reviews/_mapping/field/content Retrieving mapping for the author.email field \u00b6 GET /reviews/_mapping/field/author.email","title":"Retrieving mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/retrieving-mappings/#retrieving-mappings","text":"","title":"Retrieving mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/retrieving-mappings/#retrieving-mappings-for-the-reviews-index","text":"GET /reviews/_mapping","title":"Retrieving mappings for the reviews index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/retrieving-mappings/#retrieving-mapping-for-the-content-field","text":"GET /reviews/_mapping/field/content","title":"Retrieving mapping for the content field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/retrieving-mappings/#retrieving-mapping-for-the-authoremail-field","text":"GET /reviews/_mapping/field/author.email","title":"Retrieving mapping for the author.email field"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-arrays/","text":"Understanding arrays \u00b6 Arrays of strings are concatenated when analyzed \u00b6 POST /_analyze { \"text\": [\"Strings are simply\", \"merged together.\"], \"analyzer\": \"standard\" }","title":"Understanding arrays"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-arrays/#understanding-arrays","text":"","title":"Understanding arrays"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-arrays/#arrays-of-strings-are-concatenated-when-analyzed","text":"POST /_analyze { \"text\": [\"Strings are simply\", \"merged together.\"], \"analyzer\": \"standard\" }","title":"Arrays of strings are concatenated when analyzed"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/","text":"Understanding type coercion \u00b6 Supplying a floating point \u00b6 PUT /coercion_test/_doc/1 { \"price\": 7.4 } Supplying a floating point within a string \u00b6 PUT /coercion_test/_doc/2 { \"price\": \"7.4\" } Supplying an invalid value \u00b6 PUT /coercion_test/_doc/3 { \"price\": \"7.4m\" } Retrieve document \u00b6 GET /coercion_test/_doc/2 Clean up \u00b6 DELETE /coercion_test","title":"Understanding type coercion"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#understanding-type-coercion","text":"","title":"Understanding type coercion"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#supplying-a-floating-point","text":"PUT /coercion_test/_doc/1 { \"price\": 7.4 }","title":"Supplying a floating point"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#supplying-a-floating-point-within-a-string","text":"PUT /coercion_test/_doc/2 { \"price\": \"7.4\" }","title":"Supplying a floating point within a string"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#supplying-an-invalid-value","text":"PUT /coercion_test/_doc/3 { \"price\": \"7.4m\" }","title":"Supplying an invalid value"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#retrieve-document","text":"GET /coercion_test/_doc/2","title":"Retrieve document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/understanding-type-coercion/#clean-up","text":"DELETE /coercion_test","title":"Clean up"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/","text":"Updating analyzers \u00b6 Add description mapping using my_custom_analyzer \u00b6 PUT /analyzer_test/_mapping { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_custom_analyzer\" } } } Index a test document \u00b6 POST /analyzer_test/_doc { \"description\": \"Is that Peter's cute-looking dog?\" } Search query using keyword analyzer \u00b6 GET /analyzer_test/_search { \"query\": { \"match\": { \"description\": { \"query\": \"that\", \"analyzer\": \"keyword\" } } } } Close analyzer_test index \u00b6 POST /analyzer_test/_close Update my_custom_analyzer (remove stop token filter) \u00b6 PUT /analyzer_test/_settings { \"analysis\": { \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"char_filter\": [\"html_strip\"], \"filter\": [ \"lowercase\", \"asciifolding\" ] } } } } Open analyzer_test index \u00b6 POST /analyzer_test/_open Retrieve index settings \u00b6 GET /analyzer_test/_settings Reindex documents \u00b6 POST /analyzer_test/_update_by_query?conflicts=proceed","title":"Updating analyzers"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#updating-analyzers","text":"","title":"Updating analyzers"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#add-description-mapping-using-my_custom_analyzer","text":"PUT /analyzer_test/_mapping { \"properties\": { \"description\": { \"type\": \"text\", \"analyzer\": \"my_custom_analyzer\" } } }","title":"Add description mapping using my_custom_analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#index-a-test-document","text":"POST /analyzer_test/_doc { \"description\": \"Is that Peter's cute-looking dog?\" }","title":"Index a test document"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#search-query-using-keyword-analyzer","text":"GET /analyzer_test/_search { \"query\": { \"match\": { \"description\": { \"query\": \"that\", \"analyzer\": \"keyword\" } } } }","title":"Search query using keyword analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#close-analyzer_test-index","text":"POST /analyzer_test/_close","title":"Close analyzer_test index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#update-my_custom_analyzer-remove-stop-token-filter","text":"PUT /analyzer_test/_settings { \"analysis\": { \"analyzer\": { \"my_custom_analyzer\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"char_filter\": [\"html_strip\"], \"filter\": [ \"lowercase\", \"asciifolding\" ] } } } }","title":"Update my_custom_analyzer (remove stop token filter)"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#open-analyzer_test-index","text":"POST /analyzer_test/_open","title":"Open analyzer_test index"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#retrieve-index-settings","text":"GET /analyzer_test/_settings","title":"Retrieve index settings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-analyzers/#reindex-documents","text":"POST /analyzer_test/_update_by_query?conflicts=proceed","title":"Reindex documents"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-existing-mappings/","text":"Updating existing mappings \u00b6 Generally, field mappings cannot be updated \u00b6 This query won't work. PUT /reviews/_mapping { \"properties\": { \"product_id\": { \"type\": \"keyword\" } } } Some mapping parameters can be changed \u00b6 The ignore_above mapping parameter can be updated, for instance. PUT /reviews/_mapping { \"properties\": { \"author\": { \"properties\": { \"email\": { \"type\": \"keyword\", \"ignore_above\": 256 } } } } }","title":"Updating existing mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-existing-mappings/#updating-existing-mappings","text":"","title":"Updating existing mappings"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-existing-mappings/#generally-field-mappings-cannot-be-updated","text":"This query won't work. PUT /reviews/_mapping { \"properties\": { \"product_id\": { \"type\": \"keyword\" } } }","title":"Generally, field mappings cannot be updated"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/updating-existing-mappings/#some-mapping-parameters-can-be-changed","text":"The ignore_above mapping parameter can be updated, for instance. PUT /reviews/_mapping { \"properties\": { \"author\": { \"properties\": { \"email\": { \"type\": \"keyword\", \"ignore_above\": 256 } } } } }","title":"Some mapping parameters can be changed"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-dot-notation-in-field-names/","text":"Using dot notation in field names \u00b6 Using dot notation for the author object \u00b6 PUT /reviews_dot_notation { \"mappings\": { \"properties\": { \"rating\": { \"type\": \"float\" }, \"content\": { \"type\": \"text\" }, \"product_id\": { \"type\": \"integer\" }, \"author.first_name\": { \"type\": \"text\" }, \"author.last_name\": { \"type\": \"text\" }, \"author.email\": { \"type\": \"keyword\" } } } } Retrieve mapping \u00b6 GET /reviews_dot_notation/_mapping","title":"Using dot notation in field names"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-dot-notation-in-field-names/#using-dot-notation-in-field-names","text":"","title":"Using dot notation in field names"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-dot-notation-in-field-names/#using-dot-notation-for-the-author-object","text":"PUT /reviews_dot_notation { \"mappings\": { \"properties\": { \"rating\": { \"type\": \"float\" }, \"content\": { \"type\": \"text\" }, \"product_id\": { \"type\": \"integer\" }, \"author.first_name\": { \"type\": \"text\" }, \"author.last_name\": { \"type\": \"text\" }, \"author.email\": { \"type\": \"keyword\" } } } }","title":"Using dot notation for the author object"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-dot-notation-in-field-names/#retrieve-mapping","text":"GET /reviews_dot_notation/_mapping","title":"Retrieve mapping"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-the-analyze-api/","text":"Using the Analyze API \u00b6 Analyzing a string with the standard analyzer \u00b6 POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"analyzer\": \"standard\" } Building the equivalent of the standard analyzer \u00b6 POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"char_filter\": [], \"tokenizer\": \"standard\", \"filter\": [\"lowercase\"] }","title":"Using the Analyze API"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-the-analyze-api/#using-the-analyze-api","text":"","title":"Using the Analyze API"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-the-analyze-api/#analyzing-a-string-with-the-standard-analyzer","text":"POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"analyzer\": \"standard\" }","title":"Analyzing a string with the standard analyzer"},{"location":"Elastic_Stack/Mapping%20%26%20Analysis/using-the-analyze-api/#building-the-equivalent-of-the-standard-analyzer","text":"POST /_analyze { \"text\": \"2 guys walk into a bar, but the third... DUCKS! :-)\", \"char_filter\": [], \"tokenizer\": \"standard\", \"filter\": [\"lowercase\"] }","title":"Building the equivalent of the standard analyzer"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/","text":"Exercises \u00b6 Matching documents with a sold field of less than 10 \u00b6 GET /products/_search { \"query\": { \"range\": { \"sold\": { \"lt\": 10 } } } } Matching documents with a sold field between 10 (inclusive) and 30 (exclusive) \u00b6 GET /products/_search { \"query\": { \"range\": { \"sold\": { \"lt\": 30, \"gte\": 10 } } } } Matching documents containing the tag Meat \u00b6 GET /products/_search { \"query\": { \"term\": { \"tags.keyword\": \"Meat\" } } } Matching documents containing Tomato or Paste within the name field \u00b6 GET /products/_search { \"query\": { \"terms\": { \"name\": [ \"Tomato\", \"Paste\" ] } } } Matching documents containing past followed by an optional character, for the name field \u00b6 GET /products/_search { \"query\": { \"wildcard\": { \"name\": \"past?\" } } } Matching documents containing a number within the name field \u00b6 GET /products/_search { \"query\": { \"regexp\": { \"name\": \"[0-9]+\" } } }","title":"Exercises"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#exercises","text":"","title":"Exercises"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-with-a-sold-field-of-less-than-10","text":"GET /products/_search { \"query\": { \"range\": { \"sold\": { \"lt\": 10 } } } }","title":"Matching documents with a sold field of less than 10"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-with-a-sold-field-between-10-inclusive-and-30-exclusive","text":"GET /products/_search { \"query\": { \"range\": { \"sold\": { \"lt\": 30, \"gte\": 10 } } } }","title":"Matching documents with a sold field between 10 (inclusive) and 30 (exclusive)"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-containing-the-tag-meat","text":"GET /products/_search { \"query\": { \"term\": { \"tags.keyword\": \"Meat\" } } }","title":"Matching documents containing the tag Meat"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-containing-tomato-or-paste-within-the-name-field","text":"GET /products/_search { \"query\": { \"terms\": { \"name\": [ \"Tomato\", \"Paste\" ] } } }","title":"Matching documents containing Tomato or Paste within the name field"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-containing-past-followed-by-an-optional-character-for-the-name-field","text":"GET /products/_search { \"query\": { \"wildcard\": { \"name\": \"past?\" } } }","title":"Matching documents containing past followed by an optional character, for the name field"},{"location":"Elastic_Stack/Term%20Level%20Queries/exercises/#matching-documents-containing-a-number-within-the-name-field","text":"GET /products/_search { \"query\": { \"regexp\": { \"name\": \"[0-9]+\" } } }","title":"Matching documents containing a number within the name field"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-based-on-prefixes/","text":"Matching based on prefixes \u00b6 Matching documents containing a tag beginning with Vege \u00b6 GET /products/_search { \"query\": { \"prefix\": { \"tags.keyword\": \"Vege\" } } }","title":"Matching based on prefixes"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-based-on-prefixes/#matching-based-on-prefixes","text":"","title":"Matching based on prefixes"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-based-on-prefixes/#matching-documents-containing-a-tag-beginning-with-vege","text":"GET /products/_search { \"query\": { \"prefix\": { \"tags.keyword\": \"Vege\" } } }","title":"Matching documents containing a tag beginning with Vege"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-non-null-values/","text":"Matching documents with non-null values \u00b6 GET /products/_search { \"query\": { \"exists\": { \"field\": \"tags\" } } }","title":"Matching documents with non-null values"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-non-null-values/#matching-documents-with-non-null-values","text":"GET /products/_search { \"query\": { \"exists\": { \"field\": \"tags\" } } }","title":"Matching documents with non-null values"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-range-values/","text":"Matching documents with range values \u00b6 Matching documents with an in_stock field of between 1 and 5 , both included \u00b6 GET /products/_search { \"query\": { \"range\": { \"in_stock\": { \"gte\": 1, \"lte\": 5 } } } } Matching documents with a date range \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01\", \"lte\": \"2010/12/31\" } } } } Matching documents with a date range and custom date format \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"01-01-2010\", \"lte\": \"31-12-2010\", \"format\": \"dd-MM-yyyy\" } } } }","title":"Matching documents with range values"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-range-values/#matching-documents-with-range-values","text":"","title":"Matching documents with range values"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-range-values/#matching-documents-with-an-in_stock-field-of-between-1-and-5-both-included","text":"GET /products/_search { \"query\": { \"range\": { \"in_stock\": { \"gte\": 1, \"lte\": 5 } } } }","title":"Matching documents with an in_stock field of between 1 and 5, both included"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-range-values/#matching-documents-with-a-date-range","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01\", \"lte\": \"2010/12/31\" } } } }","title":"Matching documents with a date range"},{"location":"Elastic_Stack/Term%20Level%20Queries/matching-documents-with-range-values/#matching-documents-with-a-date-range-and-custom-date-format","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"01-01-2010\", \"lte\": \"31-12-2010\", \"format\": \"dd-MM-yyyy\" } } } }","title":"Matching documents with a date range and custom date format"},{"location":"Elastic_Stack/Term%20Level%20Queries/retrieving-documents-based-on-ids/","text":"Retrieving documents based on IDs \u00b6 GET /products/_search { \"query\": { \"ids\": { \"values\": [ 1, 2, 3 ] } } }","title":"Retrieving documents based on IDs"},{"location":"Elastic_Stack/Term%20Level%20Queries/retrieving-documents-based-on-ids/#retrieving-documents-based-on-ids","text":"GET /products/_search { \"query\": { \"ids\": { \"values\": [ 1, 2, 3 ] } } }","title":"Retrieving documents based on IDs"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-for-a-term/","text":"Searching for a term \u00b6 Matching documents with a value of true for the is_active field \u00b6 GET /products/_search { \"query\": { \"term\": { \"is_active\": true } } } GET /products/_search { \"query\": { \"term\": { \"is_active\": { \"value\": true } } } }","title":"Searching for a term"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-for-a-term/#searching-for-a-term","text":"","title":"Searching for a term"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-for-a-term/#matching-documents-with-a-value-of-true-for-the-is_active-field","text":"GET /products/_search { \"query\": { \"term\": { \"is_active\": true } } } GET /products/_search { \"query\": { \"term\": { \"is_active\": { \"value\": true } } } }","title":"Matching documents with a value of true for the is_active field"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-for-multiple-terms/","text":"Searching for multiple terms \u00b6 GET /products/_search { \"query\": { \"terms\": { \"tags.keyword\": [ \"Soup\", \"Cake\" ] } } }","title":"Searching for multiple terms"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-for-multiple-terms/#searching-for-multiple-terms","text":"GET /products/_search { \"query\": { \"terms\": { \"tags.keyword\": [ \"Soup\", \"Cake\" ] } } }","title":"Searching for multiple terms"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-regular-expressions/","text":"Searching with regular expressions \u00b6 GET /products/_search { \"query\": { \"regexp\": { \"tags.keyword\": \"Veg[a-zA-Z]+ble\" } } }","title":"Searching with regular expressions"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-regular-expressions/#searching-with-regular-expressions","text":"GET /products/_search { \"query\": { \"regexp\": { \"tags.keyword\": \"Veg[a-zA-Z]+ble\" } } }","title":"Searching with regular expressions"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-wildcards/","text":"Searching with wildcards \u00b6 Adding an asterisk for any characters (zero or more) \u00b6 GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veg*ble\" } } } Adding a question mark for any single character \u00b6 GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veg?ble\" } } } GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veget?ble\" } } }","title":"Searching with wildcards"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-wildcards/#searching-with-wildcards","text":"","title":"Searching with wildcards"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-wildcards/#adding-an-asterisk-for-any-characters-zero-or-more","text":"GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veg*ble\" } } }","title":"Adding an asterisk for any characters (zero or more)"},{"location":"Elastic_Stack/Term%20Level%20Queries/searching-with-wildcards/#adding-a-question-mark-for-any-single-character","text":"GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veg?ble\" } } } GET /products/_search { \"query\": { \"wildcard\": { \"tags.keyword\": \"Veget?ble\" } } }","title":"Adding a question mark for any single character"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/","text":"Working with relative dates \u00b6 Subtracting one year from 2010/01/01 \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y\" } } } } Subtracting one year and one day from 2010/01/01 \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y-1d\" } } } } Subtracting one year from 2010/01/01 and rounding by month \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y/M\" } } } } Rounding by month before subtracting one year from 2010/01/01 \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||/M-1y\" } } } } Rounding by month before subtracting one year from the current date \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"now/M-1y\" } } } } Matching documents with a created field containing the current date or later \u00b6 GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"now\" } } } }","title":"Working with relative dates"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#working-with-relative-dates","text":"","title":"Working with relative dates"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#subtracting-one-year-from-20100101","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y\" } } } }","title":"Subtracting one year from 2010/01/01"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#subtracting-one-year-and-one-day-from-20100101","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y-1d\" } } } }","title":"Subtracting one year and one day from 2010/01/01"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#subtracting-one-year-from-20100101-and-rounding-by-month","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||-1y/M\" } } } }","title":"Subtracting one year from 2010/01/01 and rounding by month"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#rounding-by-month-before-subtracting-one-year-from-20100101","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"2010/01/01||/M-1y\" } } } }","title":"Rounding by month before subtracting one year from 2010/01/01"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#rounding-by-month-before-subtracting-one-year-from-the-current-date","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"now/M-1y\" } } } }","title":"Rounding by month before subtracting one year from the current date"},{"location":"Elastic_Stack/Term%20Level%20Queries/working-with-relative-dates/#matching-documents-with-a-created-field-containing-the-current-date-or-later","text":"GET /products/_search { \"query\": { \"range\": { \"created\": { \"gte\": \"now\" } } } }","title":"Matching documents with a created field containing the current date or later"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/","text":"Part 1: Intro to Elasticsearch & Kibana \u00b6 Workshop objectives: - understand a use case of Elasticsearch and Kibana - understand the basic architecture of Elasticsearch - perform CRUD(Create, Read, Update, and Delete) operations with Elasticsearch and Kibana Getting information about cluster and nodes \u00b6 Syntax: GET _API/parameter Get info about cluster health \u00b6 GET _cluster/health Expected response from Elasticsearch: Get info about nodes in a cluster \u00b6 GET _nodes/stats Expected response from Elasticsearch: Performing CRUD operations \u00b6 Create \u00b6 Create an index \u00b6 Syntax: PUT Name-of-the-Index Example: PUT favorite_candy Expected response from Elasticsearch: Index a document \u00b6 When indexing a document, both HTTP verbs POST or PUT can be used. 1) Use POST when you want Elasticsearch to autogenerate an id for your document. Syntax: POST Name-of-the-Index/_doc { \"field\": \"value\" } ```` Example: ```http POST favorite_candy/_doc { \"first_name\": \"Lisa\", \"candy\": \"Sour Skittles\" } Expected response from Elasticsearch: 2) Use PUT when you want to assign a specific id to your document(i.e. if your document has a natural identifier - purchase order number, patient id, & etc). For more detailed explanation, check out this documentation from Elastic! Syntax: PUT Name-of-the-Index/_doc/id-you-want-to-assign-to-this-document { \"field\": \"value\" } Example: PUT favorite_candy/_doc/1 { \"first_name\": \"John\", \"candy\": \"Starburst\" } _create Endpoint \u00b6 When you index a document using an id that already exists, the existing document is overwritten by the new document. If you do not want a existing document to be overwritten, you can use the _create endpoint! With the _create Endpoint, no indexing will occur and you will get a 409 error message. Syntax: PUT Name-of-the-Index/_create/id-you-want-to-assign-to-this-document { \"field\": \"value\" } Example: PUT favorite_candy/_create/1 { \"first_name\": \"Finn\", \"candy\": \"Jolly Ranchers\" } Expected response from Elasticsearch: READ \u00b6 Read a document \u00b6 Syntax: GET Name-of-the-Index/_doc/id-of-the-document-you-want-to-retrieve Example: GET favorite_candy/_doc/1 Expected response from Elasticsearch: UPDATE \u00b6 Update a document \u00b6 If you want to update fields in a document, use the following syntax: POST Name-of-the-Index/_update/id-of-the-document-you-want-to-update { \"doc\": { \"field1\": \"value\", \"field2\": \"value\", } } Example: POST favorite_candy/_update/1 { \"doc\": { \"candy\": \"M&M's\" } } Expected response from Elasticsearch: DELETE \u00b6 Delete a document \u00b6 Syntax: DELETE Name-of-the-Index/_doc/id-of-the-document-you-want-to-delete Example: DELETE favorite_candy/_doc/1 Expected response from Elasticsearch: Take Home Assignment \u00b6 Create an index called places. Pick five of the places you want to visit after the pandemic is over. For each place, index a document containing the name and the country. Read(GET) each document to check the content of the document. Update a field of a document. Read(GET) the updated document to ensure that the field has been updated. Delete a document of one place. Copy and paste the following request to return all documents from the places index. This is a great way to check whether all the CRUD operations you have performed thus far have worked! GET places/_search { \"query\": { \"match_all\": {} } }","title":"Part 1: Intro to Elasticsearch & Kibana"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#part-1-intro-to-elasticsearch-kibana","text":"Workshop objectives: - understand a use case of Elasticsearch and Kibana - understand the basic architecture of Elasticsearch - perform CRUD(Create, Read, Update, and Delete) operations with Elasticsearch and Kibana","title":"Part 1: Intro to Elasticsearch &amp; Kibana"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#getting-information-about-cluster-and-nodes","text":"Syntax: GET _API/parameter","title":"Getting information about cluster and nodes"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#get-info-about-cluster-health","text":"GET _cluster/health Expected response from Elasticsearch:","title":"Get info about cluster health"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#get-info-about-nodes-in-a-cluster","text":"GET _nodes/stats Expected response from Elasticsearch:","title":"Get info about nodes in a cluster"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#performing-crud-operations","text":"","title":"Performing CRUD operations"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#create","text":"","title":"Create"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#create-an-index","text":"Syntax: PUT Name-of-the-Index Example: PUT favorite_candy Expected response from Elasticsearch:","title":"Create an index"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#index-a-document","text":"When indexing a document, both HTTP verbs POST or PUT can be used. 1) Use POST when you want Elasticsearch to autogenerate an id for your document. Syntax: POST Name-of-the-Index/_doc { \"field\": \"value\" } ```` Example: ```http POST favorite_candy/_doc { \"first_name\": \"Lisa\", \"candy\": \"Sour Skittles\" } Expected response from Elasticsearch: 2) Use PUT when you want to assign a specific id to your document(i.e. if your document has a natural identifier - purchase order number, patient id, & etc). For more detailed explanation, check out this documentation from Elastic! Syntax: PUT Name-of-the-Index/_doc/id-you-want-to-assign-to-this-document { \"field\": \"value\" } Example: PUT favorite_candy/_doc/1 { \"first_name\": \"John\", \"candy\": \"Starburst\" }","title":"Index a document"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#_create-endpoint","text":"When you index a document using an id that already exists, the existing document is overwritten by the new document. If you do not want a existing document to be overwritten, you can use the _create endpoint! With the _create Endpoint, no indexing will occur and you will get a 409 error message. Syntax: PUT Name-of-the-Index/_create/id-you-want-to-assign-to-this-document { \"field\": \"value\" } Example: PUT favorite_candy/_create/1 { \"first_name\": \"Finn\", \"candy\": \"Jolly Ranchers\" } Expected response from Elasticsearch:","title":"_create Endpoint"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#read","text":"","title":"READ"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#read-a-document","text":"Syntax: GET Name-of-the-Index/_doc/id-of-the-document-you-want-to-retrieve Example: GET favorite_candy/_doc/1 Expected response from Elasticsearch:","title":"Read a document"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#update","text":"","title":"UPDATE"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#update-a-document","text":"If you want to update fields in a document, use the following syntax: POST Name-of-the-Index/_update/id-of-the-document-you-want-to-update { \"doc\": { \"field1\": \"value\", \"field2\": \"value\", } } Example: POST favorite_candy/_update/1 { \"doc\": { \"candy\": \"M&M's\" } } Expected response from Elasticsearch:","title":"Update a document"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#delete","text":"","title":"DELETE"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#delete-a-document","text":"Syntax: DELETE Name-of-the-Index/_doc/id-of-the-document-you-want-to-delete Example: DELETE favorite_candy/_doc/1 Expected response from Elasticsearch:","title":"Delete a document"},{"location":"Elastic_Stack_Tutorial/Part_1_Intro_to_Elasticsearch_%26_Kibana/#take-home-assignment","text":"Create an index called places. Pick five of the places you want to visit after the pandemic is over. For each place, index a document containing the name and the country. Read(GET) each document to check the content of the document. Update a field of a document. Read(GET) the updated document to ensure that the field has been updated. Delete a document of one place. Copy and paste the following request to return all documents from the places index. This is a great way to check whether all the CRUD operations you have performed thus far have worked! GET places/_search { \"query\": { \"match_all\": {} } }","title":"Take Home Assignment"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/","text":"Part 2: Understanding the relevance of your search with Elasticsearch and Kibana \u00b6 Workshop objectives: - learn how Precision and Recall are used to measure how well Elastic search engine is searching - understand how scoring is used to rank the relevance of your search results in Elasticsearch - master how to send search queries from Kibana to Elasticsearch to finetune Precision or Recall of your search results Search for information \u00b6 There are two main ways to search in Elasticsearch: 1) Queries 2) Aggregations Queries \u00b6 Queries retrieve documents that match the criteria. Retrieve information about documents in an index \u00b6 Syntax: GET enter_name_of_the_index_here/_search Example: GET news_headlines/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits and a sample of 10 search results by default. Get the exact total number of hits \u00b6 To improve the response speed on large datasets, Elasticsearch limits the total count to 10,000 by default. If you want the exact total number of hits, use the following query. Syntax: GET enter_name_of_the_index_here/_search { \"track_total_hits\": true } Example: GET news_headlines/_search { \"track_total_hits\": true } Expected response from Elasticsearch: You will see that the total number of hits is now 200,853. Search for data within a specific time range \u00b6 Syntax: GET enter_name_of_the_index_here/_search { \"query\": { \"Specify the type of query here\": { \"Enter name of the field here\": { \"gte\": \"Enter lowest value of the range here\", \"lte\": \"Enter highest value of the range here\" } } } } ```` Example: GET news_headlines/_search { \"query\": { \"range\": { \"date\": { \"gte\": \"2015-06-20\", \"lte\": \"2015-09-22\" } } } } Expected response from Elasticsearch: It will pull up articles published from June 20, 2015 through September 22, 2015. A document from the result set was shown as an example. ![image](https://user-images.githubusercontent.com/60980933/105539632-41096180-5cb2-11eb-917f-85f9ba01073e.png) ### Aggregations An aggregation summarizes your data as metrics, statistics, and other analytics. #### Analyze the data to show the categories of news headlines in our dataset Syntax: GET enter_name_of_the_index_here/_search { \"aggs\": { \"name your aggregation here\": { \"specify aggregation type here\": { \"field\": \"name the field you want to aggregate here\", \"size\": state how many buckets you want returned here } } } } Example: GET news_headlines/_search { \"aggs\": { \"by_category\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected response from Elasticsearch: ![image](https://user-images.githubusercontent.com/60980933/105434428-cc361900-5c18-11eb-9db7-e7441ac5a1ac.png) ### A combination of query and aggregation request #### Search for the most significant term in a category Syntax: GET enter_name_of_the_index_here/_search { \"query\": { \"match\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregation here\": { \"significant_text\": { \"field\": \"Enter the name of the field you are searching for\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"category\": \"ENTERTAINMENT\" } }, \"aggregations\": { \"popular_in_entertainment\": { \"significant_text\": { \"field\": \"headline\" } } } } Expected response from Elasticsearch: ![image](https://user-images.githubusercontent.com/60980933/105541764-7c595f80-5cb5-11eb-86e7-ffa44ba18d74.png) ### Precision and Recall #### Increasing Recall Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\" } } } } Expected response from Elasticsearch: By default, the match query uses an \"OR\" logic. If a document contains one of the search terms, Elasticsearch will consider that document as a hit. \"OR\" logic results in higher number of hits, thereby increasing recall. However, the hits are loosely related to the query and lowering precision as a result. ![image](https://user-images.githubusercontent.com/60980933/105553748-3d320b00-5cc3-11eb-9aeb-a9970c60f4fc.png) #### Increasing Precision We can increase precision by adding an \"and\" operator to the query. Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\", \"operator\": \"and\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\", \"operator\": \"and\" } } } } Expected response from Elasticsearch: \"AND\" operator will result in getting more precise matches, thereby increasing precision. However, it will reduce the number of hits returned, resulting in lower recall. ![image](https://user-images.githubusercontent.com/60980933/105552915-e24be400-5cc1-11eb-8881-4f6534cc6aa8.png) #### minimum_should_match This parameter allows you to specify the minimum number of terms a document should have to be included in the search results. This parameter gives you more control over fine tuning precision and recall of your search. Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Enter search term here\", \"minimum_should_match\": Enter a number here } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\", \"minimum_should_match\": 3 } } } } ``` Expected response from Elasticsearch: With minimum_should_match parameter, we were able to finetune both precision and recall!","title":"Part 2 Understanding the relevance of your search with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#part-2-understanding-the-relevance-of-your-search-with-elasticsearch-and-kibana","text":"Workshop objectives: - learn how Precision and Recall are used to measure how well Elastic search engine is searching - understand how scoring is used to rank the relevance of your search results in Elasticsearch - master how to send search queries from Kibana to Elasticsearch to finetune Precision or Recall of your search results","title":"Part 2: Understanding the relevance of your search with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#search-for-information","text":"There are two main ways to search in Elasticsearch: 1) Queries 2) Aggregations","title":"Search for information"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#queries","text":"Queries retrieve documents that match the criteria.","title":"Queries"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#retrieve-information-about-documents-in-an-index","text":"Syntax: GET enter_name_of_the_index_here/_search Example: GET news_headlines/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits and a sample of 10 search results by default.","title":"Retrieve information about documents in an index"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#get-the-exact-total-number-of-hits","text":"To improve the response speed on large datasets, Elasticsearch limits the total count to 10,000 by default. If you want the exact total number of hits, use the following query. Syntax: GET enter_name_of_the_index_here/_search { \"track_total_hits\": true } Example: GET news_headlines/_search { \"track_total_hits\": true } Expected response from Elasticsearch: You will see that the total number of hits is now 200,853.","title":"Get the exact total number of hits"},{"location":"Elastic_Stack_Tutorial/Part_2_Understanding_the_relevance_of_your_search_with_Elasticsearch_and_Kibana/#search-for-data-within-a-specific-time-range","text":"Syntax: GET enter_name_of_the_index_here/_search { \"query\": { \"Specify the type of query here\": { \"Enter name of the field here\": { \"gte\": \"Enter lowest value of the range here\", \"lte\": \"Enter highest value of the range here\" } } } } ```` Example: GET news_headlines/_search { \"query\": { \"range\": { \"date\": { \"gte\": \"2015-06-20\", \"lte\": \"2015-09-22\" } } } } Expected response from Elasticsearch: It will pull up articles published from June 20, 2015 through September 22, 2015. A document from the result set was shown as an example. ![image](https://user-images.githubusercontent.com/60980933/105539632-41096180-5cb2-11eb-917f-85f9ba01073e.png) ### Aggregations An aggregation summarizes your data as metrics, statistics, and other analytics. #### Analyze the data to show the categories of news headlines in our dataset Syntax: GET enter_name_of_the_index_here/_search { \"aggs\": { \"name your aggregation here\": { \"specify aggregation type here\": { \"field\": \"name the field you want to aggregate here\", \"size\": state how many buckets you want returned here } } } } Example: GET news_headlines/_search { \"aggs\": { \"by_category\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected response from Elasticsearch: ![image](https://user-images.githubusercontent.com/60980933/105434428-cc361900-5c18-11eb-9db7-e7441ac5a1ac.png) ### A combination of query and aggregation request #### Search for the most significant term in a category Syntax: GET enter_name_of_the_index_here/_search { \"query\": { \"match\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregation here\": { \"significant_text\": { \"field\": \"Enter the name of the field you are searching for\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"category\": \"ENTERTAINMENT\" } }, \"aggregations\": { \"popular_in_entertainment\": { \"significant_text\": { \"field\": \"headline\" } } } } Expected response from Elasticsearch: ![image](https://user-images.githubusercontent.com/60980933/105541764-7c595f80-5cb5-11eb-86e7-ffa44ba18d74.png) ### Precision and Recall #### Increasing Recall Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\" } } } } Expected response from Elasticsearch: By default, the match query uses an \"OR\" logic. If a document contains one of the search terms, Elasticsearch will consider that document as a hit. \"OR\" logic results in higher number of hits, thereby increasing recall. However, the hits are loosely related to the query and lowering precision as a result. ![image](https://user-images.githubusercontent.com/60980933/105553748-3d320b00-5cc3-11eb-9aeb-a9970c60f4fc.png) #### Increasing Precision We can increase precision by adding an \"and\" operator to the query. Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\", \"operator\": \"and\" } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\", \"operator\": \"and\" } } } } Expected response from Elasticsearch: \"AND\" operator will result in getting more precise matches, thereby increasing precision. However, it will reduce the number of hits returned, resulting in lower recall. ![image](https://user-images.githubusercontent.com/60980933/105552915-e24be400-5cc1-11eb-8881-4f6534cc6aa8.png) #### minimum_should_match This parameter allows you to specify the minimum number of terms a document should have to be included in the search results. This parameter gives you more control over fine tuning precision and recall of your search. Syntax: GET enter_name_of_index_here/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Enter search term here\", \"minimum_should_match\": Enter a number here } } } } Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Khloe Kardashian Kendall Jenner\", \"minimum_should_match\": 3 } } } } ``` Expected response from Elasticsearch: With minimum_should_match parameter, we were able to finetune both precision and recall!","title":"Search for data within a specific time range"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/","text":"Part 3: Running full text queries and combined queries with Elasticsearch and Kibana \u00b6 Workshop objectives: - delve deeper into advanced queries designed to search text fields - build a combination of queries to answer more complex questions - fine-tune the relevance of search results Review from Workshop Part 2 \u00b6 There are two main ways to search in Elasticsearch: 1) Queries retrieve documents that match the specified criteria. 2) Aggregations present the summary of your data as metrics, statistics, and other analytics. Search queries \u00b6 Get information about documents in an index \u00b6 The following query will retrieve all documents that exist in the specified index. This query is a great way to explore the structure and content of your document. Syntax: GET Enter_name_of_the_index_here/_search Example: GET news_headlines/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits and a sample of 10 search results by default. The field \"_ source\"(line 22) lists all fields(the content) of a document. Aggregations Request \u00b6 Analyze the data to show the categories of news headlines in our dataset \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"aggregations\": { \"Name your aggregation here\": { \"Specify aggregation type here\": { \"field\": \"Name the field you want to aggregate here\", \"size\": State how many buckets you want returned here } } } } Example: GET news_headlines/_search { \"aggregations\": { \"by_category\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected response from Elasticsearch: When you minimize hits(line 10), you will see the aggregations report we named by_category. This report displays all categories that exist in our datset as well as the number of documents that fall under each category. Full Text Queries \u00b6 Searching for search terms \u00b6 The match query is a standard query for performing a full text search. This query retrieves documents that contain the search terms. It uses \"OR\" logic by default, meaning that it will retrieve documents that contain any one of the search terms. The order and the proximity in which the search terms are found(i.e. phrases) are not taken into account. Syntax: GET Enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } } Searching for a phrase \u00b6 What happens when you use the match query to search for phrases? \u00b6 Let's search for articles about Ed Sheeran's song \"Shape of you\" using the match query . Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Shape of you\" } } } } Expected response from Elasticsearch: Elasticsearch returns greater than 10,000 hits. The top hit as well as many others in the search results only contain the search terms \"you\" and \"shape\". These terms are not found in the same order or in proximity to each other as the search terms \"Shape of you\". When the match query is used to search for a phrase, it has high recall but low precision as it returns a lot of loosely related documents. Along with a few articles about the song \"Shape of you\", it pulls up articles about being in shape or what shape of your face says about you. When the match query is used to search for a phrase, it has high recall but low precision. It pulls up more loosely related documents as it uses \"OR\" logic by default. It pulls up documents that contains any one of the search terms in the specified field. Moreover, the order and the proximity in which the search terms are found are not taken into account. Searching for phrases using the match_phrase query \u00b6 If the order and the proximity in which the search terms are found(i.e. phrases) are important in determining the relevance of your search, you use the match_phrase query . Syntax: GET Enter_name_of_index_here/_search { \"query\": { \"match_phrase\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } } Example: GET news_headlines/_search { \"query\": { \"match_phrase\": { \"headline\": { \"query\": \"Shape of You\" } } } } When the match_phrase parameter is used, all hits must meet the following criteria: 1. the search terms \"Shape\", \"of\", and \"you\" must appear in the field headline . 2. the terms must appear in that order. 3. the terms must appear next to each other. Expected response from Elasticsearch: With match_phrase parameter, we get 3 hits returned. All 3 hits satisfy the criteria mentioned above. The match_phrase parameter yields higher precision but lower recall as it takes the order and the proximity in which the search terms are found into account. Running a match query against multiple fields \u00b6 When designing a query , you don't always know the context of a user's search. When a user searches for \"Michelle Obama\", the user could be searching for statements written by Michelle Obama or articles written about her. To accommodate these contexts, you can write a multi_match query , which searches for terms in multiple fields. The multi_match query runs a match query on multiple fields and calculates a score for each field. Then, it assigns the highest score among the fields to the document. This score will determine the ranking of the document within the search results. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search terms here\", \"fields\": [ \"List the field you want to search over\", \"List the field you want to search over\", \"List the field you want to search over\" ] } } } ```` The following `multi_match query` asks Elasticsearch to `query` documents that contain the search terms \"Michelle\" or \"Obama\" in the fields headline, or short_description, or authors. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"Michelle Obama\", \"fields\": [ \"headline\", \"short_description\", \"authors\" ] } } } Expected response from Elasticsearch: We see 3044 hits that contain \"Michelle Obama\" in the headline or short_description or author field. While the `multi_match query` increased the recall, it decreased the precision of the hits. For example, in our search for \"Michelle Obama\" related headlines, the top hit is a news headline featuring Bernie Sanders as the main topic. In this headline, Michelle Obama is mentioned once in the field short_description. ![image](https://user-images.githubusercontent.com/60980933/127704425-c1ade381-dff4-446f-9980-1caa9a85e972.png) #### Per-field boosting Headlines mentioning \"Michelle Obama\" in the field headline are more likely to be related to our search than the headlines that mention \"Michelle Obama\" once or twice in the field short_description. To improve the precision of your search, you can designate one field to carry more weight than the others. This can be done by boosting the score of the field headline(`per-field boosting`). This is notated by adding a carat(^) symbol and number 2 to the desired field as shown below. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search terms\", \"fields\": [ \"List field you want to boost^2\", \"List field you want to search over\", \"List field you want to search over\" ] } } } The following example boosts the score of documents that contain the search terms in the field headline. If the term \"Michelle\" or \"Obama\" are found in the field headline of a document, that document is given a higher score and is ranked higher in the search results. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"Michelle Obama\", \"fields\": [ \"headline^2\", \"short_description\", \"authors\" ] } } } Expected response from Elasticsearch: `Per-field boosting` yields same number of hits(5128). However, it changes the ranking of the hits. The hits ranked higher on the list contains the search terms \"Michelle Obama\" in the boosted field, headline. ![image](https://user-images.githubusercontent.com/60980933/108877609-a5268a80-75bc-11eb-8f61-ce1d1702a6e0.png) The documents containing the search terms \"Michelle Obama\" in the field headline are more likely to be about Michelle Obama. By using the `per-field boosting`, we have improved the precision of our search! #### What happens when you use the `multi_match` query to search for a phrase? While searching for Michelle Obama, the user remembers that she is throwing a party for all of her friends this weekend. She searches for news headlines regarding \"party planning\" to get some ideas for it. She uses the `multi_match query` to search for the phrase party planning. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"party planning\", \"fields\": [ \"headline^2\", \"short_description\" ] } } } Response from Elasticsearch: This query yields a lot of hits(2846). ![image](https://user-images.githubusercontent.com/60980933/108582689-09fa9000-72f2-11eb-8e34-8f6cc4302254.png) But why does one of our top 10 hits feature Bernie Sanders **planning** a national tour for grassroots **party** activism? The terms \"party\" and \"planning\" are popular terms found in many documents. With the `multi_match query`, a document is considered as a hit if any one of these search terms were found in any one of the specified fields. It does not take into account the order or the proximity in which these search terms are found. Because of that, you will see loosely related search results included among the top hits. #### Improving precision with phrase type match You can improve the precision of a `multi_match query` by adding the \"type\":\"phrase\" to the query. The phrase type performs a `match_phrase query` on each field and calculates a score for each field. Then, it assigns the highest score among the fields to the document. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search phrase\", \"fields\": [ \"List field you want to boost^2\", \"List field you want to search over\", \"List field you want to search over\" ], \"type\": \"phrase\" } } } The following query asks Elasticsearch to look up the phrase \"party planning\" in the fields headline and short_description. Using `per field boosting`, this query assigns a higher score to documents containing the phrase \"party planning\" in the field headline. The documents that include the phrase \"party planning\" in the field headline will be ranked higher in the search results. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"party planning\", \"fields\": [ \"headline^2\", \"short_description\" ], \"type\": \"phrase\" } } } Expected response from Elasticsearch: The recall is much lower(6 vs 2846 hits) but every one of the hits have the phrase \"party planning\" in either the field headline or short_description or both. ![image](https://user-images.githubusercontent.com/60980933/108615437-4943e200-73c1-11eb-87ac-881b6a20d962.png) Among these, the hits that have the phrase \"party planning\" in the boosted field headline are ranked higher in the search results and presented towards the top of the search results. ## Combined Queries There will be times when a user asks a multi-faceted question that requires multiple `queries` to answer. For example, a user may want to find political headlines about Michelle Obama published before the year 2016. This search is actually a combination of three `queries`: 1) Query headlines that contain the search terms \"Michelle Obama\" in the field headline. 2) Query \"Michelle Obama\" headlines from the \"POLITICS\" category. 3) Query \"Michelle Obama\" headlines published before the year 2016 One of the ways you can combine these queries is through a `bool query`. ### Bool Query The [bool query](https://www.elastic.co/guide/en/elasticsearch/reference/6.8/query-dsl-bool-query.html#:~:text=Bool%20Queryedit,clause%20with%20a%20typed%20occurrence.) retrieves documents matching boolean combinations of other `queries`. With the `bool query`, you can combine multiple `queries` into one request and further specify boolean clauses to narrow down your search results. There are four clauses to choose from: 1. must 2. must_not 3. should 4. filter You can build combinations of one or more of these clauses. Each clause can contain one or multiple queries that specify the criteria of each clause. These clauses are optional and can be mixed and matched to cater to your use case. The order in which they appear does not matter either! Syntax: GET name_of_index/_search { \"query\": { \"bool\": { \"must\": [ {One or more queries can be specified here. A document MUST match all of these queries to be considered as a hit.} ], \"must_not\": [ {A document must NOT match any of the queries specified here. It it does, it is excluded from the search results.} ], \"should\": [ {A document does not have to match any queries specified here. However, it if it does match, this document is given a higher score.} ], \"filter\": [ {These filters(queries) place documents in either yes or no category. Ones that fall into the yes category are included in the hits. } ] } } } #### A combination of query and aggregation request A `bool query` can help you answer multi-faceted questions. Before we go over the four clauses of the bool query, we need to first understand what type of questions we can ask about Michelle Obama. Let's first figure out what headlines have been written about her. One way to understand that is by searching for categories of headlines that mention Michelle Obama. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregation here\": { \"Specify aggregation type here\": { \"field\": \"Name the field you want to aggregate here\", \"size\": State how many buckets you want returned here } } } } The following query ask Elasticsearch to query all data that has the phrase \"Michelle Obama\" in the headline. Then, perform aggregations on the queried data and retrieve up to 100 categories that exist in the queried data. Example: GET news_headlines/_search { \"query\": { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, \"aggregations\": { \"category_mentions\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected reponse from Elasticsearch: When you minimize the hits field(line 10), you will see an aggregations report called category_mentions. This report displays an array of all the categories that exist in the queried data and the number of headlines that have been written about each category. We see that many news headlines about Michelle Obama has been written under categories such as \"POLITICS\", \"BLACK VOICES\", \"PARENTING\", \"TASTE\", and even \"WEDDINGS\"! ![image](https://user-images.githubusercontent.com/60980933/108541130-5668b000-729f-11eb-80aa-8e37b6dc016c.png) **Now let's get back to the bool query!** With the `bool query`, you can combine multiple `queries` into one request and further specify boolean clauses to narrow down your search results. There are four clauses to choose from: - must - must_not - should - filter #### The must clause The `must clause` defines all `queries`(criteria) a document MUST match to be returned as hits. These criteria are expressed in the form of one or multiple `queries`. All `queries` in the `must clause` must be satisfied for a document to be returned as a hit. As a result, having more `queries` in the `must clause` will increase the precision of your `query`. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } The following is a `bool query` that uses the `must clause`. This `query` specifies that all hits must match the phrase \"Michelle Obama\" in the field headline and match the term \"POLITICS\" in the field category. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, { \"match\": { \"category\": \"POLITICS\" } } ] } } } Expected response from Elasticsearch: You get 45 hits. All documents contain the phrase \"Michelle Obama\" in the field headline and the term \"POLITICS\" in the field category. ![image](https://user-images.githubusercontent.com/60980933/108631596-cbff8800-7427-11eb-9ac0-2f172075f9ed.png) #### The must_not clause The `must_not` clause defines `queries`(criteria) a document MUST NOT match to be included in the search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"must_not\":[ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } What if you want all Michelle Obama headlines except for the ones that belong in the \"WEDDINGS\" category? The following `bool query` specifies that all hits must contain the phrase \"Michelle Obama\" in the field headline. However, the hits `must_not` contain the term \"WEDDINGS\" in the field category. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, \"must_not\":[ { \"match\": { \"category\": \"WEDDINGS\" } } ] } } } Expected response from Elasticsearch: This `query` increases the recall(203 hits). It pulls up all the hits that contain the phrase \"Michelle Obama\" in the field headline. Among the hits, Elasticsearch excludes all documents that contain the term \"WEDDINGS\" in the field category. ![image](https://user-images.githubusercontent.com/60980933/108631753-99a25a80-7428-11eb-819a-c284e0ebb1b1.png) #### The should clause The `should clause` adds \"nice to have\" `queries`(criteria). The documents do not need to match the \"nice to have\" `queries` to be considered as hits. However, the ones that do will be given a higher score so it shows up higher in the search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here: { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"should\":[ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } Let's talk about a scenario where we may use the `should clause`. During the Black History Month, it is possible that the user may be looking up \"Michelle Obama\" in the context of \"BLACK VOICES\" category rather than in the context of \"WEDDINGS\", \"TASTE\", or \"STYLE\" categories. To accommodate this scenario, you may write a `query` where all hits MUST contain \"Michelle Obama\" in the field headline. Having the phrase \"BLACK VOICES\" in the category is not required. However, if a document contains the phrase \"BLACK VOICES\" in the field category, this document should be given a higher score and should be placed higher in the search results. To accommodate this scenario, you would write the following `bool query`. It specifies that all hits must match the phrase \"Michelle Obama\" in the field headline. `Should` a hit match the phrase \"BLACK VOICES\" in the field category, this hit will be given a higher score and will be shown higher in the search results. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"should\":[ { \"match_phrase\": { \"category\": \"BLACK VOICES\" } } ] } } } Expected response: We should still get the same number of hits(207) as the `should clause` does not add or exclude more hits. However, you will notice that the ranking of the documents has been changed. The documents with the phrase \"BLACK VOICES\" in the field category are now presented at the top of the search results. ![image](https://user-images.githubusercontent.com/60980933/108632370-be4c0180-742b-11eb-8c03-75c7809b54b8.png) #### The filter clause The `filter clause` contains filter `queries` that place documents into either \"yes\" or \"no\" category. For example, let's say you are looking for headlines published within a certain time range. Some documents will fall within this range(yes) or do not fall within this range(no). The `filter clause` only includes documents that fall into the yes category. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ], \"filter\":{ \"range\":{ \"date\": { \"gte\": \"Enter lowest value of the range here\", \"lte\": \"Enter highest value of the range here\" } } } } } } Let's say we wanted to retrieve hits that must include the phrase \"Michelle Obama\" in the field headline. Among these hits, you want to include documents published within the date range \"2014-03-25\" and \"2016-03-25\". You `bool query` will look something like this. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"filter\":{ \"range\":{ \"date\": { \"gte\": \"2014-03-25\", \"lte\": \"2016-03-25\" } } } } } } Expected response from Elasticsearch: You will see 33 hits returned. All hits contain the phrase \"Michelle Obama\" in the field headline. All hits were published between the date range we specified under the `filter clause`. ![image](https://user-images.githubusercontent.com/60980933/108633174-15ec6c00-7430-11eb-9153-05d849673f3a.png) All right. Now that we have mastered the `bool query`, let's figure out how we can fine-tune the relevance of `bool queries`! #### Fine-tuning the relevance of bool queries There are many ways you can fine-tune the relevance of `bool queries`. One of the ways is to add multiple queries under the `should clause`. **Adding multiple queries under the should clause** This approach ensures that you maintain a high recall but also offers a way to present more precise search results at the top of your search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ], \"should\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } Let's say you want to run a search for news headlines with the phrase \"Michelle Obama\" in the field headline. But you want to favor articles that mention her biography \"Becoming\", and terms like \"women\" and \"empower\". To do this, you can add multiple `queries` to the `should clause`. This will cast a wider net because none of the `queries` in the should clause need to match. However, the ones that match the `queries` under the `should clause` will be given a higher score and placed higher in the search results. This approach allows you to maintain a high recall but also gives you a way to customize the precision of top hits. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"should\": [ { \"match\": { \"headline\": \"Becoming\" } }, { \"match\": { \"headline\": \"women\" } }, { \"match\": { \"headline\": \"empower\" } } ] } } } ``` Expected response from Elasticsearch: Adding many queries under the should clause did not reduce the number of hits(207). However, it favored documents that match the queries in the should clause and improved the precision of top search results.","title":"Part 3 Running full text queries and combined queries with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#part-3-running-full-text-queries-and-combined-queries-with-elasticsearch-and-kibana","text":"Workshop objectives: - delve deeper into advanced queries designed to search text fields - build a combination of queries to answer more complex questions - fine-tune the relevance of search results","title":"Part 3: Running full text queries and combined queries with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#review-from-workshop-part-2","text":"There are two main ways to search in Elasticsearch: 1) Queries retrieve documents that match the specified criteria. 2) Aggregations present the summary of your data as metrics, statistics, and other analytics.","title":"Review from Workshop Part 2"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#search-queries","text":"","title":"Search queries"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#get-information-about-documents-in-an-index","text":"The following query will retrieve all documents that exist in the specified index. This query is a great way to explore the structure and content of your document. Syntax: GET Enter_name_of_the_index_here/_search Example: GET news_headlines/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits and a sample of 10 search results by default. The field \"_ source\"(line 22) lists all fields(the content) of a document.","title":"Get information about documents in an index"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#aggregations-request","text":"","title":"Aggregations Request"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#analyze-the-data-to-show-the-categories-of-news-headlines-in-our-dataset","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"aggregations\": { \"Name your aggregation here\": { \"Specify aggregation type here\": { \"field\": \"Name the field you want to aggregate here\", \"size\": State how many buckets you want returned here } } } } Example: GET news_headlines/_search { \"aggregations\": { \"by_category\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected response from Elasticsearch: When you minimize hits(line 10), you will see the aggregations report we named by_category. This report displays all categories that exist in our datset as well as the number of documents that fall under each category.","title":"Analyze the data to show the categories of news headlines in our dataset"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#full-text-queries","text":"","title":"Full Text Queries"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#searching-for-search-terms","text":"The match query is a standard query for performing a full text search. This query retrieves documents that contain the search terms. It uses \"OR\" logic by default, meaning that it will retrieve documents that contain any one of the search terms. The order and the proximity in which the search terms are found(i.e. phrases) are not taken into account. Syntax: GET Enter_name_of_index_here/_search { \"query\": { \"match\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } }","title":"Searching for search terms"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#searching-for-a-phrase","text":"","title":"Searching for a phrase"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#what-happens-when-you-use-the-match-query-to-search-for-phrases","text":"Let's search for articles about Ed Sheeran's song \"Shape of you\" using the match query . Example: GET news_headlines/_search { \"query\": { \"match\": { \"headline\": { \"query\": \"Shape of you\" } } } } Expected response from Elasticsearch: Elasticsearch returns greater than 10,000 hits. The top hit as well as many others in the search results only contain the search terms \"you\" and \"shape\". These terms are not found in the same order or in proximity to each other as the search terms \"Shape of you\". When the match query is used to search for a phrase, it has high recall but low precision as it returns a lot of loosely related documents. Along with a few articles about the song \"Shape of you\", it pulls up articles about being in shape or what shape of your face says about you. When the match query is used to search for a phrase, it has high recall but low precision. It pulls up more loosely related documents as it uses \"OR\" logic by default. It pulls up documents that contains any one of the search terms in the specified field. Moreover, the order and the proximity in which the search terms are found are not taken into account.","title":"What happens when you use the match query to search for phrases?"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#searching-for-phrases-using-the-match_phrase-query","text":"If the order and the proximity in which the search terms are found(i.e. phrases) are important in determining the relevance of your search, you use the match_phrase query . Syntax: GET Enter_name_of_index_here/_search { \"query\": { \"match_phrase\": { \"Specify the field you want to search\": { \"query\": \"Enter search terms\" } } } } Example: GET news_headlines/_search { \"query\": { \"match_phrase\": { \"headline\": { \"query\": \"Shape of You\" } } } } When the match_phrase parameter is used, all hits must meet the following criteria: 1. the search terms \"Shape\", \"of\", and \"you\" must appear in the field headline . 2. the terms must appear in that order. 3. the terms must appear next to each other. Expected response from Elasticsearch: With match_phrase parameter, we get 3 hits returned. All 3 hits satisfy the criteria mentioned above. The match_phrase parameter yields higher precision but lower recall as it takes the order and the proximity in which the search terms are found into account.","title":"Searching for phrases using the match_phrase query"},{"location":"Elastic_Stack_Tutorial/Part_3_Running_full_text_queries_and_combined_queries_with_Elasticsearch_and_Kibana/#running-a-match-query-against-multiple-fields","text":"When designing a query , you don't always know the context of a user's search. When a user searches for \"Michelle Obama\", the user could be searching for statements written by Michelle Obama or articles written about her. To accommodate these contexts, you can write a multi_match query , which searches for terms in multiple fields. The multi_match query runs a match query on multiple fields and calculates a score for each field. Then, it assigns the highest score among the fields to the document. This score will determine the ranking of the document within the search results. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search terms here\", \"fields\": [ \"List the field you want to search over\", \"List the field you want to search over\", \"List the field you want to search over\" ] } } } ```` The following `multi_match query` asks Elasticsearch to `query` documents that contain the search terms \"Michelle\" or \"Obama\" in the fields headline, or short_description, or authors. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"Michelle Obama\", \"fields\": [ \"headline\", \"short_description\", \"authors\" ] } } } Expected response from Elasticsearch: We see 3044 hits that contain \"Michelle Obama\" in the headline or short_description or author field. While the `multi_match query` increased the recall, it decreased the precision of the hits. For example, in our search for \"Michelle Obama\" related headlines, the top hit is a news headline featuring Bernie Sanders as the main topic. In this headline, Michelle Obama is mentioned once in the field short_description. ![image](https://user-images.githubusercontent.com/60980933/127704425-c1ade381-dff4-446f-9980-1caa9a85e972.png) #### Per-field boosting Headlines mentioning \"Michelle Obama\" in the field headline are more likely to be related to our search than the headlines that mention \"Michelle Obama\" once or twice in the field short_description. To improve the precision of your search, you can designate one field to carry more weight than the others. This can be done by boosting the score of the field headline(`per-field boosting`). This is notated by adding a carat(^) symbol and number 2 to the desired field as shown below. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search terms\", \"fields\": [ \"List field you want to boost^2\", \"List field you want to search over\", \"List field you want to search over\" ] } } } The following example boosts the score of documents that contain the search terms in the field headline. If the term \"Michelle\" or \"Obama\" are found in the field headline of a document, that document is given a higher score and is ranked higher in the search results. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"Michelle Obama\", \"fields\": [ \"headline^2\", \"short_description\", \"authors\" ] } } } Expected response from Elasticsearch: `Per-field boosting` yields same number of hits(5128). However, it changes the ranking of the hits. The hits ranked higher on the list contains the search terms \"Michelle Obama\" in the boosted field, headline. ![image](https://user-images.githubusercontent.com/60980933/108877609-a5268a80-75bc-11eb-8f61-ce1d1702a6e0.png) The documents containing the search terms \"Michelle Obama\" in the field headline are more likely to be about Michelle Obama. By using the `per-field boosting`, we have improved the precision of our search! #### What happens when you use the `multi_match` query to search for a phrase? While searching for Michelle Obama, the user remembers that she is throwing a party for all of her friends this weekend. She searches for news headlines regarding \"party planning\" to get some ideas for it. She uses the `multi_match query` to search for the phrase party planning. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"party planning\", \"fields\": [ \"headline^2\", \"short_description\" ] } } } Response from Elasticsearch: This query yields a lot of hits(2846). ![image](https://user-images.githubusercontent.com/60980933/108582689-09fa9000-72f2-11eb-8e34-8f6cc4302254.png) But why does one of our top 10 hits feature Bernie Sanders **planning** a national tour for grassroots **party** activism? The terms \"party\" and \"planning\" are popular terms found in many documents. With the `multi_match query`, a document is considered as a hit if any one of these search terms were found in any one of the specified fields. It does not take into account the order or the proximity in which these search terms are found. Because of that, you will see loosely related search results included among the top hits. #### Improving precision with phrase type match You can improve the precision of a `multi_match query` by adding the \"type\":\"phrase\" to the query. The phrase type performs a `match_phrase query` on each field and calculates a score for each field. Then, it assigns the highest score among the fields to the document. Syntax: GET Enter_the_name_of_the_index_here/_search { \"query\": { \"multi_match\": { \"query\": \"Enter search phrase\", \"fields\": [ \"List field you want to boost^2\", \"List field you want to search over\", \"List field you want to search over\" ], \"type\": \"phrase\" } } } The following query asks Elasticsearch to look up the phrase \"party planning\" in the fields headline and short_description. Using `per field boosting`, this query assigns a higher score to documents containing the phrase \"party planning\" in the field headline. The documents that include the phrase \"party planning\" in the field headline will be ranked higher in the search results. Example: GET news_headlines/_search { \"query\": { \"multi_match\": { \"query\": \"party planning\", \"fields\": [ \"headline^2\", \"short_description\" ], \"type\": \"phrase\" } } } Expected response from Elasticsearch: The recall is much lower(6 vs 2846 hits) but every one of the hits have the phrase \"party planning\" in either the field headline or short_description or both. ![image](https://user-images.githubusercontent.com/60980933/108615437-4943e200-73c1-11eb-87ac-881b6a20d962.png) Among these, the hits that have the phrase \"party planning\" in the boosted field headline are ranked higher in the search results and presented towards the top of the search results. ## Combined Queries There will be times when a user asks a multi-faceted question that requires multiple `queries` to answer. For example, a user may want to find political headlines about Michelle Obama published before the year 2016. This search is actually a combination of three `queries`: 1) Query headlines that contain the search terms \"Michelle Obama\" in the field headline. 2) Query \"Michelle Obama\" headlines from the \"POLITICS\" category. 3) Query \"Michelle Obama\" headlines published before the year 2016 One of the ways you can combine these queries is through a `bool query`. ### Bool Query The [bool query](https://www.elastic.co/guide/en/elasticsearch/reference/6.8/query-dsl-bool-query.html#:~:text=Bool%20Queryedit,clause%20with%20a%20typed%20occurrence.) retrieves documents matching boolean combinations of other `queries`. With the `bool query`, you can combine multiple `queries` into one request and further specify boolean clauses to narrow down your search results. There are four clauses to choose from: 1. must 2. must_not 3. should 4. filter You can build combinations of one or more of these clauses. Each clause can contain one or multiple queries that specify the criteria of each clause. These clauses are optional and can be mixed and matched to cater to your use case. The order in which they appear does not matter either! Syntax: GET name_of_index/_search { \"query\": { \"bool\": { \"must\": [ {One or more queries can be specified here. A document MUST match all of these queries to be considered as a hit.} ], \"must_not\": [ {A document must NOT match any of the queries specified here. It it does, it is excluded from the search results.} ], \"should\": [ {A document does not have to match any queries specified here. However, it if it does match, this document is given a higher score.} ], \"filter\": [ {These filters(queries) place documents in either yes or no category. Ones that fall into the yes category are included in the hits. } ] } } } #### A combination of query and aggregation request A `bool query` can help you answer multi-faceted questions. Before we go over the four clauses of the bool query, we need to first understand what type of questions we can ask about Michelle Obama. Let's first figure out what headlines have been written about her. One way to understand that is by searching for categories of headlines that mention Michelle Obama. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregation here\": { \"Specify aggregation type here\": { \"field\": \"Name the field you want to aggregate here\", \"size\": State how many buckets you want returned here } } } } The following query ask Elasticsearch to query all data that has the phrase \"Michelle Obama\" in the headline. Then, perform aggregations on the queried data and retrieve up to 100 categories that exist in the queried data. Example: GET news_headlines/_search { \"query\": { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, \"aggregations\": { \"category_mentions\": { \"terms\": { \"field\": \"category\", \"size\": 100 } } } } Expected reponse from Elasticsearch: When you minimize the hits field(line 10), you will see an aggregations report called category_mentions. This report displays an array of all the categories that exist in the queried data and the number of headlines that have been written about each category. We see that many news headlines about Michelle Obama has been written under categories such as \"POLITICS\", \"BLACK VOICES\", \"PARENTING\", \"TASTE\", and even \"WEDDINGS\"! ![image](https://user-images.githubusercontent.com/60980933/108541130-5668b000-729f-11eb-80aa-8e37b6dc016c.png) **Now let's get back to the bool query!** With the `bool query`, you can combine multiple `queries` into one request and further specify boolean clauses to narrow down your search results. There are four clauses to choose from: - must - must_not - should - filter #### The must clause The `must clause` defines all `queries`(criteria) a document MUST match to be returned as hits. These criteria are expressed in the form of one or multiple `queries`. All `queries` in the `must clause` must be satisfied for a document to be returned as a hit. As a result, having more `queries` in the `must clause` will increase the precision of your `query`. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } The following is a `bool query` that uses the `must clause`. This `query` specifies that all hits must match the phrase \"Michelle Obama\" in the field headline and match the term \"POLITICS\" in the field category. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, { \"match\": { \"category\": \"POLITICS\" } } ] } } } Expected response from Elasticsearch: You get 45 hits. All documents contain the phrase \"Michelle Obama\" in the field headline and the term \"POLITICS\" in the field category. ![image](https://user-images.githubusercontent.com/60980933/108631596-cbff8800-7427-11eb-9ac0-2f172075f9ed.png) #### The must_not clause The `must_not` clause defines `queries`(criteria) a document MUST NOT match to be included in the search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"must_not\":[ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } What if you want all Michelle Obama headlines except for the ones that belong in the \"WEDDINGS\" category? The following `bool query` specifies that all hits must contain the phrase \"Michelle Obama\" in the field headline. However, the hits `must_not` contain the term \"WEDDINGS\" in the field category. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": { \"match_phrase\": { \"headline\": \"Michelle Obama\" } }, \"must_not\":[ { \"match\": { \"category\": \"WEDDINGS\" } } ] } } } Expected response from Elasticsearch: This `query` increases the recall(203 hits). It pulls up all the hits that contain the phrase \"Michelle Obama\" in the field headline. Among the hits, Elasticsearch excludes all documents that contain the term \"WEDDINGS\" in the field category. ![image](https://user-images.githubusercontent.com/60980933/108631753-99a25a80-7428-11eb-819a-c284e0ebb1b1.png) #### The should clause The `should clause` adds \"nice to have\" `queries`(criteria). The documents do not need to match the \"nice to have\" `queries` to be considered as hits. However, the ones that do will be given a higher score so it shows up higher in the search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here: { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"should\":[ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } Let's talk about a scenario where we may use the `should clause`. During the Black History Month, it is possible that the user may be looking up \"Michelle Obama\" in the context of \"BLACK VOICES\" category rather than in the context of \"WEDDINGS\", \"TASTE\", or \"STYLE\" categories. To accommodate this scenario, you may write a `query` where all hits MUST contain \"Michelle Obama\" in the field headline. Having the phrase \"BLACK VOICES\" in the category is not required. However, if a document contains the phrase \"BLACK VOICES\" in the field category, this document should be given a higher score and should be placed higher in the search results. To accommodate this scenario, you would write the following `bool query`. It specifies that all hits must match the phrase \"Michelle Obama\" in the field headline. `Should` a hit match the phrase \"BLACK VOICES\" in the field category, this hit will be given a higher score and will be shown higher in the search results. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"should\":[ { \"match_phrase\": { \"category\": \"BLACK VOICES\" } } ] } } } Expected response: We should still get the same number of hits(207) as the `should clause` does not add or exclude more hits. However, you will notice that the ranking of the documents has been changed. The documents with the phrase \"BLACK VOICES\" in the field category are now presented at the top of the search results. ![image](https://user-images.githubusercontent.com/60980933/108632370-be4c0180-742b-11eb-8c03-75c7809b54b8.png) #### The filter clause The `filter clause` contains filter `queries` that place documents into either \"yes\" or \"no\" category. For example, let's say you are looking for headlines published within a certain time range. Some documents will fall within this range(yes) or do not fall within this range(no). The `filter clause` only includes documents that fall into the yes category. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ], \"filter\":{ \"range\":{ \"date\": { \"gte\": \"Enter lowest value of the range here\", \"lte\": \"Enter highest value of the range here\" } } } } } } Let's say we wanted to retrieve hits that must include the phrase \"Michelle Obama\" in the field headline. Among these hits, you want to include documents published within the date range \"2014-03-25\" and \"2016-03-25\". You `bool query` will look something like this. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"filter\":{ \"range\":{ \"date\": { \"gte\": \"2014-03-25\", \"lte\": \"2016-03-25\" } } } } } } Expected response from Elasticsearch: You will see 33 hits returned. All hits contain the phrase \"Michelle Obama\" in the field headline. All hits were published between the date range we specified under the `filter clause`. ![image](https://user-images.githubusercontent.com/60980933/108633174-15ec6c00-7430-11eb-9153-05d849673f3a.png) All right. Now that we have mastered the `bool query`, let's figure out how we can fine-tune the relevance of `bool queries`! #### Fine-tuning the relevance of bool queries There are many ways you can fine-tune the relevance of `bool queries`. One of the ways is to add multiple queries under the `should clause`. **Adding multiple queries under the should clause** This approach ensures that you maintain a high recall but also offers a way to present more precise search results at the top of your search results. Syntax: GET Enter_name_of_the_index_here/_search { \"query\": { \"bool\": { \"must\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ], \"should\": [ { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } } ] } } } Let's say you want to run a search for news headlines with the phrase \"Michelle Obama\" in the field headline. But you want to favor articles that mention her biography \"Becoming\", and terms like \"women\" and \"empower\". To do this, you can add multiple `queries` to the `should clause`. This will cast a wider net because none of the `queries` in the should clause need to match. However, the ones that match the `queries` under the `should clause` will be given a higher score and placed higher in the search results. This approach allows you to maintain a high recall but also gives you a way to customize the precision of top hits. Example: GET news_headlines/_search { \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"headline\": \"Michelle Obama\" } } ], \"should\": [ { \"match\": { \"headline\": \"Becoming\" } }, { \"match\": { \"headline\": \"women\" } }, { \"match\": { \"headline\": \"empower\" } } ] } } } ``` Expected response from Elasticsearch: Adding many queries under the should clause did not reduce the number of hits(207). However, it favored documents that match the queries in the should clause and improved the precision of top search results.","title":"Running a match query against multiple fields"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/","text":"Beginner's Crash Course to Elastic Stack Series \u00b6 Part 4: Running Aggregations with Elasticsearch and Kibana \u00b6 Welcome to the Beginner's Crash Course to Elastic Stack! This repo contains all resources shared during Part 4: Running Aggregations with Elasticsearch and Kibana. We search for things on a daily basis. Sometimes, we seek to retrieve documents based on the specific criteria(i.e. retrieving songs by our favorite artist). Other times, we seek to gain insight by summarizing our data(i.e. Report on monthly revenue generated by an artist\u2019s concert tour). Throughout the Beginner\u2019s Crash Course, we primarily focused on retrieving documents by sending queries to Elasticsearch. This workshop will focus on aggregations, which summarizes your data as metrics, statistics, or other analytics! By the end of this workshop, you will be able to run: - metric aggregations - buckets aggregations - combined aggregations Live workshop attendees The answers to questions asked during the live workshop are included here ! Set up data within Elasticsearch \u00b6 Often times, the dataset is not optimal for running requests in its original state. For example, the type of a field may not be recognized by Elasticsearch or the dataset may contain a value that was accidentally included in the wrong field and etc. These are exact problems that I ran into while working with this dataset. The following are the requests that I sent to yield the results shared during the workshop. Copy and paste these requests into the Kibana console(Dev Tools) and run these requests in the order shown below. STEP 1: Create a new index(ecommerce_data) with the following mapping. PUT ecommerce_data { \"mappings\": { \"properties\": { \"Country\": { \"type\": \"keyword\" }, \"CustomerID\": { \"type\": \"long\" }, \"Description\": { \"type\": \"text\" }, \"InvoiceDate\": { \"type\": \"date\", \"format\": \"M/d/yyyy H:m\" }, \"InvoiceNo\": { \"type\": \"keyword\" }, \"Quantity\": { \"type\": \"long\" }, \"StockCode\": { \"type\": \"keyword\" }, \"UnitPrice\": { \"type\": \"double\" } } } } STEP 2: Reindex the data from the original index(source) to the one you just created(destination). POST _reindex { \"source\": { \"index\": \"name of your original index when you added the data to Elasticsearch\" }, \"dest\": { \"index\": \"ecommerce_data\" } } STEP 3: Remove the negative values from the field \"UnitPrice\". When you explore the minimum unit price in this dataset, you will see that the minimum unit price value is -11062.06. To keep our data simple, I used the delete_by_query API to remove all unit prices less than 0. POST ecommerce_data/_delete_by_query { \"query\": { \"range\": { \"UnitPrice\": { \"lte\": 0 } } } } STEP 4: Remove values greater than 500 from the field \"UnitPrice\". When you explore the maximum unit price in this dataset, you will see that the maximum unit price value is 38,970. When the data is manually examined, the majority of the unit prices are less than 500. The max value of 38,970 would skew the average. To simplify our demo, I used the delete_by_query API to remove all unit prices greater than 500. POST ecommerce_data/_delete_by_query { \"query\": { \"range\": { \"UnitPrice\": { \"gte\": 500 } } } } Review from previous workshops \u00b6 There are two main ways to search in Elasticsearch: 1) Queries retrieve documents that match the specified criteria. 2) Aggregations present the summary of your data as metrics, statistics, and other analytics. Get information about documents in an index \u00b6 The following query will retrieve information about documents in the ecommerce_data index. This query is a great way to explore the structure and content of your document. Syntax: GET Enter_name_of_the_index_here/_search Example: GET ecommerce_data/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits(line 12) and a sample of 10 search results by default(lines 16+). The first hit(a document) is shown on lines 17-31. The field \"source\"(line 22) lists all the fields(the content) of the document. Aggregations Request \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"Specify the aggregation type here\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Metric Aggregations \u00b6 Metric aggregations are used to compute numeric values based on your dataset. It can be used to calculate the values of sum , min , max , avg , unique count( cardinality ) and etc. Compute the sum of all unit prices in the index \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"sum\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"aggs\": { \"sum_unit_price\": { \"sum\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: By default, Elasticsearch returns top 10 hits(Lines 16+). When you minimize hits(red box- line 10), you will see the aggregations results we named sum_unit_price(image below). It displays the sum of all unit prices present in our index. If the purpose of running an aggregation is solely to get the aggregations results, you can add a size parameter and set it to 0 as shown below. This parameter prevents Elasticsearch from fetching the top 10 hits so that the aggregations results are shown at the top of the response. Using a size parameter Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"sum_unit_price\": { \"sum\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: We no longer need to minimize the hits to get access to the aggregations results! We will be setting the size parameter to 0 in all aggregations requests from this point on. Compute the lowest( min ) unit price of an item \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"min\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"lowest_unit_price\": { \"min\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The lowest unit price of an item is 1.01. Compute the highest( max ) unit price of an item \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"max\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"highest_unit_price\": { \"max\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The highest unit price of an item is 498.79. Compute the average unit price of items \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"avg\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"average_unit_price\": { \"avg\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The average unit price of an item is ~4.39. Stats Aggregation: Compute the count, min, max, avg, sum in one go \u00b6 Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"stats\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"all_stats_unit_price\": { \"stats\": { \"field\": \"UnitPrice\" } } } } Expected Response from Elasticsearch: The stats aggregation will yield the values of count (the number of unit prices aggregation was performed on), min , max , avg , and sum (sum of all unit prices in the index). Cardinality Aggregation \u00b6 The cardinality aggregation computes the count of unique values for a given field. Syntax: GET Enter_name_of_the_index_here { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"cardinality\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"number_unique_customers\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } Expected response from Elasticsearch: Approximately, there are 4325 unique number of customers in our index. Limiting the scope of an aggregation \u00b6 In the previous examples, aggregations were performed on all documents in the ecommerce_data index. What if you want to run an aggregation on a subset of the documents? For example, our index contains e-commerce data from multiple countries. Let's say you want to calculate the average unit price of items sold in Germany. To limit the scope of the aggregation, you can add a query clause to the aggregations request. The query clause defines the subset of documents that aggregations should be performed on. The combined query and aggregations look like the following. Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"query\": { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregations here\": { \"Specify aggregations type here\": { \"field\": \"Name the field you want to aggregate here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"query\": { \"match\": { \"Country\": \"Germany\" } }, \"aggs\": { \"germany_average_unit_price\": { \"avg\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The average of unit price of items sold in Germany is ~4.58. The combination of query and aggregations request allowed us to perform aggregations on a subset of documents. What if we wanted to perform aggregations on several subsets of documents? This is where Bucket Aggregations come into play! Bucket Aggregations \u00b6 When you want to aggregate on several subsets of documents, bucket aggregations will come in handy. Bucket aggregations group documents into several sets of documents called buckets. All documents in a bucket share a common criteria. The following are different types of bucket aggregations . Date Histogram Aggregation Histogram Aggregation Range Aggregation Terms aggregation 1. Date Histogram Aggregation \u00b6 When you are looking to group data by time interval, the date_histogram aggregation will prove very useful! Our ecommerce_data index contains transaction data that has been collected over time(from the year 2010 to 2011). If we are looking to get insights about transactions over time, our first instinct should be to run the date_histogram aggregation . There are two ways to define a time interval with date_histogram aggregation . These are Fixed_interval and Calendar_interval . Fixed_interval With the fixed_interval , the interval is always constant . Example: Create a bucket for every 8 hour interval. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"date_histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"fixed_interval\": \"Specify the interval here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_8_hrs\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"fixed_interval\": \"8h\" } } } } Expected response from Elasticsearch: Elasticsearch creates a bucket for every 8 hours(\"key_as_string\") and shows the number of documents(\"doc_count\") grouped into each bucket. Another way we can define the time interval is through the calendar_interval . Calendar_interval With the calendar_interval , the interval may vary . For example, we could choose a time interval of day, month or year. But daylight savings can change the length of specific days, months can have different number of days, and leap seconds can be tacked onto a particular year. So the time interval of day, month, or leap seconds could vary! A scenario where you might use the calendar_interval is when you want to calculate the monthly revenue. Ex. Split data into monthly buckets. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"date_histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"calendar_interval\": \"Specify the interval here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_month\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"1M\" } } } } Expected response from Elasticsearch: Elasticsearch creates monthly buckets. Within each bucket, the date(monthly interval) is included in the field \"key_as_string\". The field \"key\" shows the same date represented as a timestamp. The field \"doc_count\" shows the number of documents that fall within the time interval. Bucket sorting for date histogram aggregation By default, the date_histogram aggregation sorts buckets based on the \"key\" values in ascending order. To reverse this order, you can add an order parameter to the aggregations as shown below. Then, specify that you want to sort buckets based on the \"_key\" values in descending(desc) order. Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_month\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"1M\", \"order\": { \"_key\": \"desc\" } } } } } Expected response from Elasticsearch: You will see that buckets are now sorted to return the most recent interval first. Histogram Aggregation \u00b6 With the date_histogram aggregation , we were able to create buckets based on time intervals. The histogram aggregation creates buckets based on any numerical interval. Ex. Create a buckets based on price interval that increases in increments of 10. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"interval\": Specify the interval here } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_price_interval\": { \"histogram\": { \"field\": \"UnitPrice\", \"interval\": 10 } } } } Expected response from Elasticsearch: Elasticsearch returns a buckets array where each bucket represents a price interval(\"key\"). Each interval increases in increments of 10 in unit price. It also includes the number of documents placed in each bucket(\"doc_count\"). Bucket sorting for histogram aggregation By default, the histogram aggregation sorts buckets based on the _key values in ascending order. To reverse this order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on the _key values in descending(desc) order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_price_interval\": { \"histogram\": { \"field\": \"UnitPrice\", \"interval\": 10, \"order\": { \"_key\": \"desc\" } } } } } Expected response from Elasticsearch: You will see that the buckets are now sorted to return the price intervals in descending order. g) Range Aggregation \u00b6 The range aggregation is similar to the histogram aggregation in that it can create buckets based on any numerical interval. The difference is that the range aggregation allows you to define intervals of varying sizes so you can customize it to your use case. For example, what if you wanted to know the number of transactions for items from varying price ranges(between 0 and $50, between \\(50-\\) 200, and between $200 and up)? Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"range\": { \"field\": \"Name the field you want to aggregate on here\", \"ranges\": [ { \"to\": x }, { \"from\": x, \"to\": y }, { \"from\": z } ] } } } } ```` Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_custom_price_ranges\": { \"range\": { \"field\": \"UnitPrice\", \"ranges\": [ { \"to\": 50 }, { \"from\": 50, \"to\": 200 }, { \"from\": 200 } ] } } } } Expected response from Elasticsearch: Elasticsearch returns a buckets array where each bucket represents a customized price interval(\"key\"). It also includes the number of documents(\"doc_count\") placed in each bucket. ![image](https://user-images.githubusercontent.com/60980933/114792261-44f2d000-9d45-11eb-9298-6bae6dcf8f06.png) **Bucket sorting for range aggregation** The `range aggregation` is sorted based on the input ranges you specify and it cannot be sorted any other way! #### Terms Aggregation The `terms aggregation` creates a new bucket for every unique term it encounters for the specified field. It is often used to find the most frequently found terms in a document. For example, let's say you want to identify 5 customers with the highest number of transactions(documents). Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"terms\": { \"field\": \"Name the field you want to aggregate on here\", \"size\": State how many top results you want returned here } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"top_5_customers\": { \"terms\": { \"field\": \"CustomerID\", \"size\": 5 } } } } Expected response from Elasticsearch: Elasticsearch will return 5 customer IDs(\"key\") with the highest number of transactions(\"doc_count\"). ![image](https://user-images.githubusercontent.com/60980933/114796514-6906df00-9d4e-11eb-862e-ac8eed4a10e2.png) **Bucket sorting for terms aggregation** By default, the `terms aggregation` sorts buckets based on the \"doc_count\" values in descending order. To reverse this order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on the `_count` values in ascending(asc) order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"5_customers_with_lowest_number_of_transactions\": { \"terms\": { \"field\": \"CustomerID\", \"size\": 5, \"order\": { \"_count\": \"asc\" } } } } } Expected response from Elasticsearch: You will see that the buckets are now sorted in ascending order of \"doc_count\", showing buckets with the lowest \"doc_count\" first. ![image](https://user-images.githubusercontent.com/60980933/116301597-77e18e80-a75d-11eb-835a-2fda2883bc5e.png) ### Combined Aggregations So far, we have ran `metric aggregations` or `bucket aggregations` to answer simple questions. There will be times when we will ask more complex questions that require running combinations of these aggregations. For example, let's say we wanted to know the sum of revenue per day. To get the answer, we need to first split our data into daily buckets(`date_histogram aggregation`). ![image](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3mcqa7qs9pi7bosopwjr.png) Within each bucket, we need to perform `metric aggregations` to calculate the daily revenue. ![image](https://user-images.githubusercontent.com/60980933/136267632-7ef1e51b-56f6-4a94-b67d-a44eaabbe1bf.png) #### Calculate the daily revenue The combined `aggregations` request looks like the following: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\" }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } } } } } } Expected Response from Elasticsearch: Elasticsearch returns an array of daily buckets. Within each bucket, it shows the number of documents(\"doc_count\") within each bucket as well as the revenue generated from each day(\"daily_revenue\"). ![image](https://user-images.githubusercontent.com/60980933/115085623-0df8f780-9ec8-11eb-81a5-a2da7d5759c1.png) #### Calculating multiple metrics per bucket You can also calculate multiple metrics per bucket. For example, let's say you wanted to calculate the daily revenue and the number of unique customers per day in one go. To do this, you can add multiple `metric aggregations` per bucket as shown below! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\" }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } }, \"number_of_unique_customers_per_day\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } } } Expected Response from Elasticsearch: Elasticsearch returns an array of daily buckets. Within each bucket, you will see that the \"number_of_unique_customers_per_day\" and the \"daily_revenue\" have been calculated for each day! ![image](https://user-images.githubusercontent.com/60980933/115086712-08041600-9eca-11eb-9afe-43923477b371.png) **Sorting by metric value of a sub-aggregation** You do not always need to sort by time interval, numerical interval, or by doc_count! You can also sort by metric value of `sub-aggregations`. Let's take a look at the request below. Within the `sub-aggregation`, metric values \"daily_revenue\" and \"number_of_unique_customers_per_day\" are calculated. Let's say you wanted to find which day had the highest daily revenue to date! All you need to do is to add the \"order\" parameter( and sort buckets based on the metric value of \"daily_revenue\" in descending(\"desc\") order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\", \"order\": { \"daily_revenue\": \"desc\" } }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } }, \"number_of_unique_customers_per_day\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } } } ``` Expected response from Elasticsearch: You will see that the response is no longer sorted by date. The buckets are now sorted to return the highest daily revenue first! Q and A from the live workshop \u00b6 1. Aggregated result is based on shard level correct? Yes, you are correct! Aggregation is performed on every shard and the results from every shard are sent to the coordinator node. The coordinator node merges the shard results together into one final response which is sent to the user. 2. Does this include bookends? So are there duplicates at the 50.0 and 200? I was just wondering if it went for example 0-50 and 50.+ to 200.0 and then 200.+ What a great question! I assume you are referring to the range aggregation example where I set the ranges from 0-50, 50-200, and 200+. Let's take 0-50 range for example. This range has a lower limit(0) and a upper limit(50). When it comes to range in Elasticsearch, the lower limit is included but the upper limit is excluded. So the range 0-50 grabs everything from 0 upto but not including 50. 3. What about Time Weighted Average, is it possible? At present, Elasticsearch does not have a built in feature that automatically calculates the time weighted average. However, you can always write a script that represents the formula for calculating the time weighted average and include it in the aggregation. Here is a documentation on how to write scripts !","title":"Beginner's Crash Course to Elastic Stack Series"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#beginners-crash-course-to-elastic-stack-series","text":"","title":"Beginner's Crash Course to Elastic Stack Series"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#part-4-running-aggregations-with-elasticsearch-and-kibana","text":"Welcome to the Beginner's Crash Course to Elastic Stack! This repo contains all resources shared during Part 4: Running Aggregations with Elasticsearch and Kibana. We search for things on a daily basis. Sometimes, we seek to retrieve documents based on the specific criteria(i.e. retrieving songs by our favorite artist). Other times, we seek to gain insight by summarizing our data(i.e. Report on monthly revenue generated by an artist\u2019s concert tour). Throughout the Beginner\u2019s Crash Course, we primarily focused on retrieving documents by sending queries to Elasticsearch. This workshop will focus on aggregations, which summarizes your data as metrics, statistics, or other analytics! By the end of this workshop, you will be able to run: - metric aggregations - buckets aggregations - combined aggregations Live workshop attendees The answers to questions asked during the live workshop are included here !","title":"Part 4: Running Aggregations with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#set-up-data-within-elasticsearch","text":"Often times, the dataset is not optimal for running requests in its original state. For example, the type of a field may not be recognized by Elasticsearch or the dataset may contain a value that was accidentally included in the wrong field and etc. These are exact problems that I ran into while working with this dataset. The following are the requests that I sent to yield the results shared during the workshop. Copy and paste these requests into the Kibana console(Dev Tools) and run these requests in the order shown below. STEP 1: Create a new index(ecommerce_data) with the following mapping. PUT ecommerce_data { \"mappings\": { \"properties\": { \"Country\": { \"type\": \"keyword\" }, \"CustomerID\": { \"type\": \"long\" }, \"Description\": { \"type\": \"text\" }, \"InvoiceDate\": { \"type\": \"date\", \"format\": \"M/d/yyyy H:m\" }, \"InvoiceNo\": { \"type\": \"keyword\" }, \"Quantity\": { \"type\": \"long\" }, \"StockCode\": { \"type\": \"keyword\" }, \"UnitPrice\": { \"type\": \"double\" } } } } STEP 2: Reindex the data from the original index(source) to the one you just created(destination). POST _reindex { \"source\": { \"index\": \"name of your original index when you added the data to Elasticsearch\" }, \"dest\": { \"index\": \"ecommerce_data\" } } STEP 3: Remove the negative values from the field \"UnitPrice\". When you explore the minimum unit price in this dataset, you will see that the minimum unit price value is -11062.06. To keep our data simple, I used the delete_by_query API to remove all unit prices less than 0. POST ecommerce_data/_delete_by_query { \"query\": { \"range\": { \"UnitPrice\": { \"lte\": 0 } } } } STEP 4: Remove values greater than 500 from the field \"UnitPrice\". When you explore the maximum unit price in this dataset, you will see that the maximum unit price value is 38,970. When the data is manually examined, the majority of the unit prices are less than 500. The max value of 38,970 would skew the average. To simplify our demo, I used the delete_by_query API to remove all unit prices greater than 500. POST ecommerce_data/_delete_by_query { \"query\": { \"range\": { \"UnitPrice\": { \"gte\": 500 } } } }","title":"Set up data within Elasticsearch"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#review-from-previous-workshops","text":"There are two main ways to search in Elasticsearch: 1) Queries retrieve documents that match the specified criteria. 2) Aggregations present the summary of your data as metrics, statistics, and other analytics.","title":"Review from previous workshops"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#get-information-about-documents-in-an-index","text":"The following query will retrieve information about documents in the ecommerce_data index. This query is a great way to explore the structure and content of your document. Syntax: GET Enter_name_of_the_index_here/_search Example: GET ecommerce_data/_search Expected response from Elasticsearch: Elasticsearch displays a number of hits(line 12) and a sample of 10 search results by default(lines 16+). The first hit(a document) is shown on lines 17-31. The field \"source\"(line 22) lists all the fields(the content) of the document.","title":"Get information about documents in an index"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#aggregations-request","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"Specify the aggregation type here\": { \"field\": \"Name the field you want to aggregate on here\" } } } }","title":"Aggregations Request"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#metric-aggregations","text":"Metric aggregations are used to compute numeric values based on your dataset. It can be used to calculate the values of sum , min , max , avg , unique count( cardinality ) and etc.","title":"Metric Aggregations"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#compute-the-sum-of-all-unit-prices-in-the-index","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"sum\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"aggs\": { \"sum_unit_price\": { \"sum\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: By default, Elasticsearch returns top 10 hits(Lines 16+). When you minimize hits(red box- line 10), you will see the aggregations results we named sum_unit_price(image below). It displays the sum of all unit prices present in our index. If the purpose of running an aggregation is solely to get the aggregations results, you can add a size parameter and set it to 0 as shown below. This parameter prevents Elasticsearch from fetching the top 10 hits so that the aggregations results are shown at the top of the response. Using a size parameter Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"sum_unit_price\": { \"sum\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: We no longer need to minimize the hits to get access to the aggregations results! We will be setting the size parameter to 0 in all aggregations requests from this point on.","title":"Compute the sum of all unit prices in the index"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#compute-the-lowestmin-unit-price-of-an-item","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"min\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"lowest_unit_price\": { \"min\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The lowest unit price of an item is 1.01.","title":"Compute the lowest(min) unit price of an item"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#compute-the-highestmax-unit-price-of-an-item","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"max\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"highest_unit_price\": { \"max\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The highest unit price of an item is 498.79.","title":"Compute the highest(max) unit price of an item"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#compute-the-average-unit-price-of-items","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"avg\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"average_unit_price\": { \"avg\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The average unit price of an item is ~4.39.","title":"Compute the average unit price of items"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#stats-aggregation-compute-the-count-min-max-avg-sum-in-one-go","text":"Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"stats\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"all_stats_unit_price\": { \"stats\": { \"field\": \"UnitPrice\" } } } } Expected Response from Elasticsearch: The stats aggregation will yield the values of count (the number of unit prices aggregation was performed on), min , max , avg , and sum (sum of all unit prices in the index).","title":"Stats Aggregation: Compute the count, min, max, avg, sum in one go"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#cardinality-aggregation","text":"The cardinality aggregation computes the count of unique values for a given field. Syntax: GET Enter_name_of_the_index_here { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"cardinality\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"number_unique_customers\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } Expected response from Elasticsearch: Approximately, there are 4325 unique number of customers in our index.","title":"Cardinality Aggregation"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#limiting-the-scope-of-an-aggregation","text":"In the previous examples, aggregations were performed on all documents in the ecommerce_data index. What if you want to run an aggregation on a subset of the documents? For example, our index contains e-commerce data from multiple countries. Let's say you want to calculate the average unit price of items sold in Germany. To limit the scope of the aggregation, you can add a query clause to the aggregations request. The query clause defines the subset of documents that aggregations should be performed on. The combined query and aggregations look like the following. Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"query\": { \"Enter match or match_phrase here\": { \"Enter the name of the field\": \"Enter the value you are looking for\" } }, \"aggregations\": { \"Name your aggregations here\": { \"Specify aggregations type here\": { \"field\": \"Name the field you want to aggregate here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"query\": { \"match\": { \"Country\": \"Germany\" } }, \"aggs\": { \"germany_average_unit_price\": { \"avg\": { \"field\": \"UnitPrice\" } } } } Expected response from Elasticsearch: The average of unit price of items sold in Germany is ~4.58. The combination of query and aggregations request allowed us to perform aggregations on a subset of documents. What if we wanted to perform aggregations on several subsets of documents? This is where Bucket Aggregations come into play!","title":"Limiting the scope of an aggregation"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#bucket-aggregations","text":"When you want to aggregate on several subsets of documents, bucket aggregations will come in handy. Bucket aggregations group documents into several sets of documents called buckets. All documents in a bucket share a common criteria. The following are different types of bucket aggregations . Date Histogram Aggregation Histogram Aggregation Range Aggregation Terms aggregation","title":"Bucket Aggregations"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#1-date-histogram-aggregation","text":"When you are looking to group data by time interval, the date_histogram aggregation will prove very useful! Our ecommerce_data index contains transaction data that has been collected over time(from the year 2010 to 2011). If we are looking to get insights about transactions over time, our first instinct should be to run the date_histogram aggregation . There are two ways to define a time interval with date_histogram aggregation . These are Fixed_interval and Calendar_interval . Fixed_interval With the fixed_interval , the interval is always constant . Example: Create a bucket for every 8 hour interval. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"date_histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"fixed_interval\": \"Specify the interval here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_8_hrs\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"fixed_interval\": \"8h\" } } } } Expected response from Elasticsearch: Elasticsearch creates a bucket for every 8 hours(\"key_as_string\") and shows the number of documents(\"doc_count\") grouped into each bucket. Another way we can define the time interval is through the calendar_interval . Calendar_interval With the calendar_interval , the interval may vary . For example, we could choose a time interval of day, month or year. But daylight savings can change the length of specific days, months can have different number of days, and leap seconds can be tacked onto a particular year. So the time interval of day, month, or leap seconds could vary! A scenario where you might use the calendar_interval is when you want to calculate the monthly revenue. Ex. Split data into monthly buckets. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"date_histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"calendar_interval\": \"Specify the interval here\" } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_month\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"1M\" } } } } Expected response from Elasticsearch: Elasticsearch creates monthly buckets. Within each bucket, the date(monthly interval) is included in the field \"key_as_string\". The field \"key\" shows the same date represented as a timestamp. The field \"doc_count\" shows the number of documents that fall within the time interval. Bucket sorting for date histogram aggregation By default, the date_histogram aggregation sorts buckets based on the \"key\" values in ascending order. To reverse this order, you can add an order parameter to the aggregations as shown below. Then, specify that you want to sort buckets based on the \"_key\" values in descending(desc) order. Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_by_month\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"1M\", \"order\": { \"_key\": \"desc\" } } } } } Expected response from Elasticsearch: You will see that buckets are now sorted to return the most recent interval first.","title":"1. Date Histogram Aggregation"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#histogram-aggregation","text":"With the date_histogram aggregation , we were able to create buckets based on time intervals. The histogram aggregation creates buckets based on any numerical interval. Ex. Create a buckets based on price interval that increases in increments of 10. Syntax: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"histogram\": { \"field\":\"Name the field you want to aggregate on here\", \"interval\": Specify the interval here } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_price_interval\": { \"histogram\": { \"field\": \"UnitPrice\", \"interval\": 10 } } } } Expected response from Elasticsearch: Elasticsearch returns a buckets array where each bucket represents a price interval(\"key\"). Each interval increases in increments of 10 in unit price. It also includes the number of documents placed in each bucket(\"doc_count\"). Bucket sorting for histogram aggregation By default, the histogram aggregation sorts buckets based on the _key values in ascending order. To reverse this order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on the _key values in descending(desc) order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_price_interval\": { \"histogram\": { \"field\": \"UnitPrice\", \"interval\": 10, \"order\": { \"_key\": \"desc\" } } } } } Expected response from Elasticsearch: You will see that the buckets are now sorted to return the price intervals in descending order. g)","title":"Histogram Aggregation"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#range-aggregation","text":"The range aggregation is similar to the histogram aggregation in that it can create buckets based on any numerical interval. The difference is that the range aggregation allows you to define intervals of varying sizes so you can customize it to your use case. For example, what if you wanted to know the number of transactions for items from varying price ranges(between 0 and $50, between \\(50-\\) 200, and between $200 and up)? Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"range\": { \"field\": \"Name the field you want to aggregate on here\", \"ranges\": [ { \"to\": x }, { \"from\": x, \"to\": y }, { \"from\": z } ] } } } } ```` Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_custom_price_ranges\": { \"range\": { \"field\": \"UnitPrice\", \"ranges\": [ { \"to\": 50 }, { \"from\": 50, \"to\": 200 }, { \"from\": 200 } ] } } } } Expected response from Elasticsearch: Elasticsearch returns a buckets array where each bucket represents a customized price interval(\"key\"). It also includes the number of documents(\"doc_count\") placed in each bucket. ![image](https://user-images.githubusercontent.com/60980933/114792261-44f2d000-9d45-11eb-9298-6bae6dcf8f06.png) **Bucket sorting for range aggregation** The `range aggregation` is sorted based on the input ranges you specify and it cannot be sorted any other way! #### Terms Aggregation The `terms aggregation` creates a new bucket for every unique term it encounters for the specified field. It is often used to find the most frequently found terms in a document. For example, let's say you want to identify 5 customers with the highest number of transactions(documents). Syntax: GET Enter_name_of_the_index_here/_search { \"aggs\": { \"Name your aggregations here\": { \"terms\": { \"field\": \"Name the field you want to aggregate on here\", \"size\": State how many top results you want returned here } } } } Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"top_5_customers\": { \"terms\": { \"field\": \"CustomerID\", \"size\": 5 } } } } Expected response from Elasticsearch: Elasticsearch will return 5 customer IDs(\"key\") with the highest number of transactions(\"doc_count\"). ![image](https://user-images.githubusercontent.com/60980933/114796514-6906df00-9d4e-11eb-862e-ac8eed4a10e2.png) **Bucket sorting for terms aggregation** By default, the `terms aggregation` sorts buckets based on the \"doc_count\" values in descending order. To reverse this order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on the `_count` values in ascending(asc) order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"5_customers_with_lowest_number_of_transactions\": { \"terms\": { \"field\": \"CustomerID\", \"size\": 5, \"order\": { \"_count\": \"asc\" } } } } } Expected response from Elasticsearch: You will see that the buckets are now sorted in ascending order of \"doc_count\", showing buckets with the lowest \"doc_count\" first. ![image](https://user-images.githubusercontent.com/60980933/116301597-77e18e80-a75d-11eb-835a-2fda2883bc5e.png) ### Combined Aggregations So far, we have ran `metric aggregations` or `bucket aggregations` to answer simple questions. There will be times when we will ask more complex questions that require running combinations of these aggregations. For example, let's say we wanted to know the sum of revenue per day. To get the answer, we need to first split our data into daily buckets(`date_histogram aggregation`). ![image](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3mcqa7qs9pi7bosopwjr.png) Within each bucket, we need to perform `metric aggregations` to calculate the daily revenue. ![image](https://user-images.githubusercontent.com/60980933/136267632-7ef1e51b-56f6-4a94-b67d-a44eaabbe1bf.png) #### Calculate the daily revenue The combined `aggregations` request looks like the following: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\" }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } } } } } } Expected Response from Elasticsearch: Elasticsearch returns an array of daily buckets. Within each bucket, it shows the number of documents(\"doc_count\") within each bucket as well as the revenue generated from each day(\"daily_revenue\"). ![image](https://user-images.githubusercontent.com/60980933/115085623-0df8f780-9ec8-11eb-81a5-a2da7d5759c1.png) #### Calculating multiple metrics per bucket You can also calculate multiple metrics per bucket. For example, let's say you wanted to calculate the daily revenue and the number of unique customers per day in one go. To do this, you can add multiple `metric aggregations` per bucket as shown below! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\" }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } }, \"number_of_unique_customers_per_day\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } } } Expected Response from Elasticsearch: Elasticsearch returns an array of daily buckets. Within each bucket, you will see that the \"number_of_unique_customers_per_day\" and the \"daily_revenue\" have been calculated for each day! ![image](https://user-images.githubusercontent.com/60980933/115086712-08041600-9eca-11eb-9afe-43923477b371.png) **Sorting by metric value of a sub-aggregation** You do not always need to sort by time interval, numerical interval, or by doc_count! You can also sort by metric value of `sub-aggregations`. Let's take a look at the request below. Within the `sub-aggregation`, metric values \"daily_revenue\" and \"number_of_unique_customers_per_day\" are calculated. Let's say you wanted to find which day had the highest daily revenue to date! All you need to do is to add the \"order\" parameter( and sort buckets based on the metric value of \"daily_revenue\" in descending(\"desc\") order! Example: GET ecommerce_data/_search { \"size\": 0, \"aggs\": { \"transactions_per_day\": { \"date_histogram\": { \"field\": \"InvoiceDate\", \"calendar_interval\": \"day\", \"order\": { \"daily_revenue\": \"desc\" } }, \"aggs\": { \"daily_revenue\": { \"sum\": { \"script\": { \"source\": \"doc['UnitPrice'].value * doc['Quantity'].value\" } } }, \"number_of_unique_customers_per_day\": { \"cardinality\": { \"field\": \"CustomerID\" } } } } } } ``` Expected response from Elasticsearch: You will see that the response is no longer sorted by date. The buckets are now sorted to return the highest daily revenue first!","title":"Range Aggregation"},{"location":"Elastic_Stack_Tutorial/Part_4_Running_Aggregations_with_Elasticsearch_and_Kibana/#q-and-a-from-the-live-workshop","text":"1. Aggregated result is based on shard level correct? Yes, you are correct! Aggregation is performed on every shard and the results from every shard are sent to the coordinator node. The coordinator node merges the shard results together into one final response which is sent to the user. 2. Does this include bookends? So are there duplicates at the 50.0 and 200? I was just wondering if it went for example 0-50 and 50.+ to 200.0 and then 200.+ What a great question! I assume you are referring to the range aggregation example where I set the ranges from 0-50, 50-200, and 200+. Let's take 0-50 range for example. This range has a lower limit(0) and a upper limit(50). When it comes to range in Elasticsearch, the lower limit is included but the upper limit is excluded. So the range 0-50 grabs everything from 0 upto but not including 50. 3. What about Time Weighted Average, is it possible? At present, Elasticsearch does not have a built in feature that automatically calculates the time weighted average. However, you can always write a script that represents the formula for calculating the time weighted average and include it in the aggregation. Here is a documentation on how to write scripts !","title":"Q and A from the live workshop"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/","text":"Part 5: Understanding Mapping with Elasticsearch and Kibana \u00b6 What is a Mapping? \u00b6 Review from Previous Workshops \u00b6 Indexing a Document \u00b6 The following request will index the following document. Syntax: POST Enter-name-of-the-index/_doc { \"field\": \"value\" } Example: POST temp_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch will confirm that this document has been successfully indexed into the temp_index. Mapping Explained \u00b6 Mapping determines how a document and its fields are indexed and stored by defining the type of each field. It contains a list of the names and types of fields in an index. Depending on its type, each field is indexed and stored differently in Elasticsearch. Dynamic Mapping \u00b6 When a user does not define mapping in advance, Elasticsearch creates or updates the mapping as needed by default. This is known as dynamic mapping . With dynamic mapping , Elasticsearch looks at each field and tries to infer the data type from the field content. Then, it assigns a type to each field and creates a list of field names and types known as mapping. Depending on the assigned field type, each field is indexed and primed for different types of requests(full text search, aggregations, sorting). This is why mapping plays an important role in how Elasticsearch stores and searches for data. View the Mapping \u00b6 Syntax: GET Enter_name_of_the_index_here/_mapping Example: GET temp_index/_mapping Expected response from Elasticsearch: Elasticsearch returns the mapping of the temp_index. It lists all the fields of the document in an alphabetical order and lists the type of each field(text, keyword, long, float, date, boolean and etc). For the list of all field types, click here ! Indexing Strings \u00b6 There are two kinds of string field types: 1. Text 2. Keyword By default, every string gets mapped twice as a text field and as a keyword multi-field. Each field type is primed for different types of requests. Text field type is designed for full-text searches. Keyword field type is designed for exact searches, aggregations, and sorting. You can customize your mapping by assigning the field type as either text or keyword or both! Text Field Type \u00b6 Text Analysis \u00b6 Ever notice that when you search in Elasticsearch, it is not case sensitive or punctuation does not seem to matter? This is because text analysis occurs when your fields are indexed. By default, strings are analyzed when it is indexed. The string is broken up into individual words also known as tokens. The analyzer further lowercases each token and removes punctuations. Inverted Index Once the string is analyzed, the individual tokens are stored in a sorted list known as the inverted index . Each unique token is stored in the inverted index with its associated ID. The same process occurs every time you index a new document. Keyword Field Type \u00b6 Keyword field type is used for aggregations, sorting, and exact searches. These actions look up the document ID to find the values it has in its fields. Keyword field is suited to perform these actions because it uses a data structure called doc values to store data. For each document, the document id along with the field value(original string) are added to the table. This data structure( doc values ) is designed for actions that require looking up the document ID to find the values it has in its fields. When Elasticsearch dynamically creates a mapping for you, it does not know what you want to use a string for so it maps all strings to both field types. In cases where you do not need both field types, the default setting is wasteful. Since both field types require creating either an inverted index or doc values, creating both field types for unnecessary fields will slow down indexing and take up more disk space. This is why we define our own mapping as it helps us store and search data more efficiently. Mapping Exercise \u00b6 Project : Build an app for a client who manages a produce warehouse This app must enable users to: 1. search for produce name, country of origin and description identify top countries of origin with the most frequent purchase history sort produce by produce type(Fruit or Vegetable) get the summary of monthly expense Sample data { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Plan of Action Defining your own mapping \u00b6 Rules 1. If you do not define a mapping ahead of time, Elasticsearch dynamically creates the mapping for you. 2. If you do decide to define your own mapping, you can do so at index creation. 3. ONE mapping is defined per index. Once the index has been created, we can only add new fields to a mapping. We CANNOT change the mapping of an existing field. 4. If you must change the type of an existing field, you must create a new index with the desired mapping, then reindex all documents into the new index. Step 1: Index a sample document into a test index. The sample document must contain the fields that you want to define. These fields must also contain values that map closely to the field types you want. Syntax: POST Name-of-test-index/_doc { \"field\": \"value\" } Example: POST test_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: The test_index is successfully created. Step 2: View the dynamic mapping Syntax: GET Name-the-index-whose-mapping-you-want-to-view/_mapping Example: GET test_index/_mapping Expected response from Elasticsearch: Elasticsearch will display the mapping it has created. It lists the fields in an alphabetical order. This document is identical to the one we indexed into the temp_index. To save space, the screenshots of the mapping has not been included here. Step 3: Edit the mapping Copy and paste the mapping from step 2 into the Kibana console. From the pasted results, remove the \"test_index\" along with its opening and closing brackets. Then, edit the mapping to satisfy the requirements outlined in the figure below. The optimized mapping should look like the following: { \"mappings\": { \"properties\": { \"botanical_name\": { \"enabled\": false }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"enabled\": false } } } } Step 4: Create a new index with the optimized mapping from step 3. Syntax: PUT Name-of-your-final-index { copy and paste your edited mapping here } Example: PUT produce_index { \"mappings\": { \"properties\": { \"botanical_name\": { \"enabled\": false }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"enabled\": false } } } } Expected response from Elasticsearch: Elasticsearch creates a produce_index with the customized mapping we defined above! Step 5: Check the mapping of the new index to make sure the all the fields have been mapped correctly Syntax: GET Name-of-test-index/_mapping Example: GET produce_index/_mapping Expected response from Elasticsearch: Compared to the dynamic mapping , our optimized mapping looks more simple and concise! The current mapping satisfies the requirements that are marked with green check marks. Step 6: Index your dataset into the new index For simplicity's sake, we will index two documents. Index the first document POST produce_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch successfully indexes the first document. Index the second document The second document has almost identical fields as the first document except that it has an extra field called \"organic\" set to true! POST produce_index/_doc { \"name\": \"Mango\", \"botanical_name\": \"Harum Manis\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"Indonesia\", \"organic\": true, \"date_purchased\": \"2020-05-02T07:15:35\", \"quantity\": 500, \"unit_price\": 1.5, \"description\": \"Mango Arumanis or Harum Manis is originated from East Java. Arumanis means harum dan manis or fragrant and sweet just like its taste. The ripe Mango Arumanis has dark green skin coated with thin grayish natural wax. The flesh is deep yellow, thick, and soft with little to no fiber. Mango Arumanis is best eaten when ripe.\", \"vendor_details\": { \"vendor\": \"Ayra Shezan Trading\", \"main_contact\": \"Suharto\", \"vendor_location\": \"Binjai, Indonesia\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch successfully indexes the second document. Let's see what happens to the mapping by sending this request below: GET produce_index/_mapping Expected response from Elasticsearch: The new field(\"organic\") and its field type(boolean) have been added to the mapping. This is in line with the rules of mapping we discussed earlier since you can add new fields to the mapping. We just cannot change the mapping of an existing field! What if you do need to make changes to the mapping of an existing field? \u00b6 Let's say your client changed his mind. He wants to run only full text search on the field \"botanical_name\" we disabled earlier. Remember, you CANNOT change the mapping of an existing field. If you do need to make changes to an existing field, you must create a new index with the desired mapping, then reindex all documents into the new index. STEP 1: Create a new index(produce_v2) with the latest mapping. We removed the \"enabled\" parameter from the field \"botanical_name\" and changed its type to \"text\". Example: PUT produce_v2 { \"mappings\": { \"properties\": { \"botanical_name\": { \"type\": \"text\" }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"organic\": { \"type\": \"boolean\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"type\": \"object\", \"enabled\": false } } } } Expected response from Elasticsearch: Elasticsearch creates a new index(produce_v2) with the latest mapping. If you check the mapping, you will see that the filed \"botanical_name\" has been typed as text. View the mapping of produce_v2: GET produce_v2/_mapping Expected response from Elasticsearch: STEP 2: Reindex the data from the original index(produce_index) to the one you just created(produce_v2). POST _reindex { \"source\": { \"index\": \"produce_index\" }, \"dest\": { \"index\": \"produce_v2\" } } Expected response from Elasticsearch: This request reindexes data from the produce_index to the produce_v2 index. The produce_v2 index can now be used to run the requests that the client has specified. Runtime Field \u00b6 Step 1: Create a runtime field and add it to the mapping of the existing index. Syntax: PUT Enter-name-of-index/_mapping { \"runtime\": { \"Name-your-runtime-field-here\": { \"type\": \"Specify-field-type-here\", \"script\": { \"source\": \"Specify the formula you want executed\" } } } } Example: PUT produce_v2/_mapping { \"runtime\": { \"total\": { \"type\": \"double\", \"script\": { \"source\": \"emit(doc['unit_price'].value* doc['quantity'].value)\" } } } } Expected response from Elasticsearch: Elasticsearch successfully adds the runtime field to the mapping. Step 2: Check the mapping: GET produce_v2/_mapping Expected response from Elasticsearch: Elasticsearch adds a runtime field to the mapping(red box). Note that the runtime field is not listed under \"properties\" object which includes the fields in our documents. This is because the runtime field \"total\" is not indexed! Step 3: Run a request on the runtime field to see it perform its magic! Please note that the following request does not aggregate the monthly expense here. We are running a simple aggregation request to demonstrate how runtime field works! The following request runs a sum aggregation against the runtime field total of all documents in our index. Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"Specify the aggregation type here\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET produce_v2/_search { \"size\": 0, \"aggs\": { \"total_expense\": { \"sum\": { \"field\": \"total\" } } } } Expected response from Elasticsearch: When this request is sent, a runtime field called \"total\" is created and calculated for documents within the scope of our request(entire index). Then, the sum aggregation is ran on the field \"total\" over all documents in our index. The runtime field is only created and calculated when a request made on the runtime field is being executed. Runtime fields are not indexed so these do not take up disk space. We also did not have to reindex in order to add a new field to existing documents. For more information on runtime fields, check out this blog !","title":"Part 5 Understanding Mapping with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#part-5-understanding-mapping-with-elasticsearch-and-kibana","text":"","title":"Part 5: Understanding Mapping with Elasticsearch and Kibana"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#what-is-a-mapping","text":"","title":"What is a Mapping?"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#review-from-previous-workshops","text":"","title":"Review from Previous Workshops"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#indexing-a-document","text":"The following request will index the following document. Syntax: POST Enter-name-of-the-index/_doc { \"field\": \"value\" } Example: POST temp_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch will confirm that this document has been successfully indexed into the temp_index.","title":"Indexing a Document"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#mapping-explained","text":"Mapping determines how a document and its fields are indexed and stored by defining the type of each field. It contains a list of the names and types of fields in an index. Depending on its type, each field is indexed and stored differently in Elasticsearch.","title":"Mapping Explained"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#dynamic-mapping","text":"When a user does not define mapping in advance, Elasticsearch creates or updates the mapping as needed by default. This is known as dynamic mapping . With dynamic mapping , Elasticsearch looks at each field and tries to infer the data type from the field content. Then, it assigns a type to each field and creates a list of field names and types known as mapping. Depending on the assigned field type, each field is indexed and primed for different types of requests(full text search, aggregations, sorting). This is why mapping plays an important role in how Elasticsearch stores and searches for data.","title":"Dynamic Mapping"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#view-the-mapping","text":"Syntax: GET Enter_name_of_the_index_here/_mapping Example: GET temp_index/_mapping Expected response from Elasticsearch: Elasticsearch returns the mapping of the temp_index. It lists all the fields of the document in an alphabetical order and lists the type of each field(text, keyword, long, float, date, boolean and etc). For the list of all field types, click here !","title":"View the Mapping"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#indexing-strings","text":"There are two kinds of string field types: 1. Text 2. Keyword By default, every string gets mapped twice as a text field and as a keyword multi-field. Each field type is primed for different types of requests. Text field type is designed for full-text searches. Keyword field type is designed for exact searches, aggregations, and sorting. You can customize your mapping by assigning the field type as either text or keyword or both!","title":"Indexing Strings"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#text-field-type","text":"","title":"Text Field Type"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#text-analysis","text":"Ever notice that when you search in Elasticsearch, it is not case sensitive or punctuation does not seem to matter? This is because text analysis occurs when your fields are indexed. By default, strings are analyzed when it is indexed. The string is broken up into individual words also known as tokens. The analyzer further lowercases each token and removes punctuations. Inverted Index Once the string is analyzed, the individual tokens are stored in a sorted list known as the inverted index . Each unique token is stored in the inverted index with its associated ID. The same process occurs every time you index a new document.","title":"Text Analysis"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#keyword-field-type","text":"Keyword field type is used for aggregations, sorting, and exact searches. These actions look up the document ID to find the values it has in its fields. Keyword field is suited to perform these actions because it uses a data structure called doc values to store data. For each document, the document id along with the field value(original string) are added to the table. This data structure( doc values ) is designed for actions that require looking up the document ID to find the values it has in its fields. When Elasticsearch dynamically creates a mapping for you, it does not know what you want to use a string for so it maps all strings to both field types. In cases where you do not need both field types, the default setting is wasteful. Since both field types require creating either an inverted index or doc values, creating both field types for unnecessary fields will slow down indexing and take up more disk space. This is why we define our own mapping as it helps us store and search data more efficiently.","title":"Keyword Field Type"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#mapping-exercise","text":"Project : Build an app for a client who manages a produce warehouse This app must enable users to: 1. search for produce name, country of origin and description identify top countries of origin with the most frequent purchase history sort produce by produce type(Fruit or Vegetable) get the summary of monthly expense Sample data { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Plan of Action","title":"Mapping Exercise"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#defining-your-own-mapping","text":"Rules 1. If you do not define a mapping ahead of time, Elasticsearch dynamically creates the mapping for you. 2. If you do decide to define your own mapping, you can do so at index creation. 3. ONE mapping is defined per index. Once the index has been created, we can only add new fields to a mapping. We CANNOT change the mapping of an existing field. 4. If you must change the type of an existing field, you must create a new index with the desired mapping, then reindex all documents into the new index. Step 1: Index a sample document into a test index. The sample document must contain the fields that you want to define. These fields must also contain values that map closely to the field types you want. Syntax: POST Name-of-test-index/_doc { \"field\": \"value\" } Example: POST test_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: The test_index is successfully created. Step 2: View the dynamic mapping Syntax: GET Name-the-index-whose-mapping-you-want-to-view/_mapping Example: GET test_index/_mapping Expected response from Elasticsearch: Elasticsearch will display the mapping it has created. It lists the fields in an alphabetical order. This document is identical to the one we indexed into the temp_index. To save space, the screenshots of the mapping has not been included here. Step 3: Edit the mapping Copy and paste the mapping from step 2 into the Kibana console. From the pasted results, remove the \"test_index\" along with its opening and closing brackets. Then, edit the mapping to satisfy the requirements outlined in the figure below. The optimized mapping should look like the following: { \"mappings\": { \"properties\": { \"botanical_name\": { \"enabled\": false }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"enabled\": false } } } } Step 4: Create a new index with the optimized mapping from step 3. Syntax: PUT Name-of-your-final-index { copy and paste your edited mapping here } Example: PUT produce_index { \"mappings\": { \"properties\": { \"botanical_name\": { \"enabled\": false }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"enabled\": false } } } } Expected response from Elasticsearch: Elasticsearch creates a produce_index with the customized mapping we defined above! Step 5: Check the mapping of the new index to make sure the all the fields have been mapped correctly Syntax: GET Name-of-test-index/_mapping Example: GET produce_index/_mapping Expected response from Elasticsearch: Compared to the dynamic mapping , our optimized mapping looks more simple and concise! The current mapping satisfies the requirements that are marked with green check marks. Step 6: Index your dataset into the new index For simplicity's sake, we will index two documents. Index the first document POST produce_index/_doc { \"name\": \"Pineapple\", \"botanical_name\": \"Ananas comosus\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"New Zealand\", \"date_purchased\": \"2020-06-02T12:15:35\", \"quantity\": 200, \"unit_price\": 3.11, \"description\": \"a large juicy tropical fruit consisting of aromatic edible yellow flesh surrounded by a tough segmented skin and topped with a tuft of stiff leaves.These pineapples are sourced from New Zealand.\", \"vendor_details\": { \"vendor\": \"Tropical Fruit Growers of New Zealand\", \"main_contact\": \"Hugh Rose\", \"vendor_location\": \"Whangarei, New Zealand\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch successfully indexes the first document. Index the second document The second document has almost identical fields as the first document except that it has an extra field called \"organic\" set to true! POST produce_index/_doc { \"name\": \"Mango\", \"botanical_name\": \"Harum Manis\", \"produce_type\": \"Fruit\", \"country_of_origin\": \"Indonesia\", \"organic\": true, \"date_purchased\": \"2020-05-02T07:15:35\", \"quantity\": 500, \"unit_price\": 1.5, \"description\": \"Mango Arumanis or Harum Manis is originated from East Java. Arumanis means harum dan manis or fragrant and sweet just like its taste. The ripe Mango Arumanis has dark green skin coated with thin grayish natural wax. The flesh is deep yellow, thick, and soft with little to no fiber. Mango Arumanis is best eaten when ripe.\", \"vendor_details\": { \"vendor\": \"Ayra Shezan Trading\", \"main_contact\": \"Suharto\", \"vendor_location\": \"Binjai, Indonesia\", \"preferred_vendor\": true } } Expected response from Elasticsearch: Elasticsearch successfully indexes the second document. Let's see what happens to the mapping by sending this request below: GET produce_index/_mapping Expected response from Elasticsearch: The new field(\"organic\") and its field type(boolean) have been added to the mapping. This is in line with the rules of mapping we discussed earlier since you can add new fields to the mapping. We just cannot change the mapping of an existing field!","title":"Defining your own mapping"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#what-if-you-do-need-to-make-changes-to-the-mapping-of-an-existing-field","text":"Let's say your client changed his mind. He wants to run only full text search on the field \"botanical_name\" we disabled earlier. Remember, you CANNOT change the mapping of an existing field. If you do need to make changes to an existing field, you must create a new index with the desired mapping, then reindex all documents into the new index. STEP 1: Create a new index(produce_v2) with the latest mapping. We removed the \"enabled\" parameter from the field \"botanical_name\" and changed its type to \"text\". Example: PUT produce_v2 { \"mappings\": { \"properties\": { \"botanical_name\": { \"type\": \"text\" }, \"country_of_origin\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } }, \"date_purchased\": { \"type\": \"date\" }, \"description\": { \"type\": \"text\" }, \"name\": { \"type\": \"text\" }, \"organic\": { \"type\": \"boolean\" }, \"produce_type\": { \"type\": \"keyword\" }, \"quantity\": { \"type\": \"long\" }, \"unit_price\": { \"type\": \"float\" }, \"vendor_details\": { \"type\": \"object\", \"enabled\": false } } } } Expected response from Elasticsearch: Elasticsearch creates a new index(produce_v2) with the latest mapping. If you check the mapping, you will see that the filed \"botanical_name\" has been typed as text. View the mapping of produce_v2: GET produce_v2/_mapping Expected response from Elasticsearch: STEP 2: Reindex the data from the original index(produce_index) to the one you just created(produce_v2). POST _reindex { \"source\": { \"index\": \"produce_index\" }, \"dest\": { \"index\": \"produce_v2\" } } Expected response from Elasticsearch: This request reindexes data from the produce_index to the produce_v2 index. The produce_v2 index can now be used to run the requests that the client has specified.","title":"What if you do need to make changes to the mapping of an existing field?"},{"location":"Elastic_Stack_Tutorial/Part_5_Understanding_Mapping_with_Elasticsearch_and_Kibana/#runtime-field","text":"Step 1: Create a runtime field and add it to the mapping of the existing index. Syntax: PUT Enter-name-of-index/_mapping { \"runtime\": { \"Name-your-runtime-field-here\": { \"type\": \"Specify-field-type-here\", \"script\": { \"source\": \"Specify the formula you want executed\" } } } } Example: PUT produce_v2/_mapping { \"runtime\": { \"total\": { \"type\": \"double\", \"script\": { \"source\": \"emit(doc['unit_price'].value* doc['quantity'].value)\" } } } } Expected response from Elasticsearch: Elasticsearch successfully adds the runtime field to the mapping. Step 2: Check the mapping: GET produce_v2/_mapping Expected response from Elasticsearch: Elasticsearch adds a runtime field to the mapping(red box). Note that the runtime field is not listed under \"properties\" object which includes the fields in our documents. This is because the runtime field \"total\" is not indexed! Step 3: Run a request on the runtime field to see it perform its magic! Please note that the following request does not aggregate the monthly expense here. We are running a simple aggregation request to demonstrate how runtime field works! The following request runs a sum aggregation against the runtime field total of all documents in our index. Syntax: GET Enter_name_of_the_index_here/_search { \"size\": 0, \"aggs\": { \"Name your aggregations here\": { \"Specify the aggregation type here\": { \"field\": \"Name the field you want to aggregate on here\" } } } } Example: GET produce_v2/_search { \"size\": 0, \"aggs\": { \"total_expense\": { \"sum\": { \"field\": \"total\" } } } } Expected response from Elasticsearch: When this request is sent, a runtime field called \"total\" is created and calculated for documents within the scope of our request(entire index). Then, the sum aggregation is ran on the field \"total\" over all documents in our index. The runtime field is only created and calculated when a request made on the runtime field is being executed. Runtime fields are not indexed so these do not take up disk space. We also did not have to reindex in order to add a new field to existing documents. For more information on runtime fields, check out this blog !","title":"Runtime Field"},{"location":"Elastic_Stack_Tutorial/Untitled/","text":"Alternative installation using Docker","title":"Untitled"}]}